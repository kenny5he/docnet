## Domain-Driven Design(领域驱动设计)
### 软件应用架构演变过程

软件架构模式的演变大体来说经历了三个阶段：

1. 单机-两层架构（C\S架构）：
   1. 采用面向过程的设计方法，系统包括客户端 UI 层和数据库两层，采用 C/S 架构模式，
   2. 整个系统围绕数据库驱动设计和开发，并且总是从设计数据库和字段开始。
2. 集中式架构-三层架构（SOA架构）：
   1. 采用面向对象的设计方法，系统包括业务接入层、业务逻辑层和数据库层
   2. 采用经典的三层架构，也有部分应用采用传统的 SOA 架构。
   3. 这种架构容易使系统变得臃肿，可扩展性和弹性伸缩性差。
3. 分布式微服务架构-DDD分层架构：
    1. 用户接口层：用户界面、web服务、其他
    2. 应用层：应用服务
    3. 领域层：聚合：实体、值对象，领域服务
    4. 基础层：数据库、总线、API网关、缓存

### DDD 10大核心概念
##### 子域
领域可以进一步划分为子领域。我们把划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围。
1. 子域可以根据自身重要性和功能属性划分为三类子域，它们分别是：核心域、通用域和支撑域。
2. 子域还可根据需要进一步拆分为子子域，比如，支付子域可继续拆分为收款和付款子子域。

##### 核心域
决定产品和公司核心竞争力的子域是核心域，它是业务成功的主要因素和公司的核心竞争力。

##### 通用域
没有太多个性化的诉求，同时被多个子域使用的通用功能子域是通用域
- 比如认证、权限等等，这类应用很容易买到，没有企业特点限制，不需要做太多的定制化

##### 支撑域
有一种功能子域是必需的，但既不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域，它就是支撑域。
- 支撑域则具有企业特性，但不具有通用性，例如数据代码类的数据字典等系统。

##### 限界上下文
界限上下文定义领域边界的利器，限界上下文本质上也是子域。
1. 通用语言定义上下文含义，可以解决交流障碍这个问题，使领域专家和开发人员能够协同合作，从而确保业务需求的正确表达。
    - 通用语言贯穿DDD整个设计过程，将业务需求准确转化为代码设计
    - 通用语言包含术语和用例场景，并且能够直接反映在代码中。
    - 通用语言中的名词可以给领域对象命名，如商品、订单等，对应实体对象； 
    - 而动词则表示一个动作或事件，如商品已下单、订单已付款等，对应领域事件或者命令。

2. 限界上下文则定义领域边界，用来封装通用语言和领域对象，提供上下文环境，
    - 保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。
    - 这个边界定义了模型的适用范围，使团队所有成员能够明确地知道什么应该在模型中实现，什么不应该在模型中实现。
        - 限界上下文确定了微服务的设计和拆分方向，是微服务设计和拆分的主要依据。
        - 如果不考虑技术异构、团队沟通等其它外部因素，一个限界上下文理论上就可以设计为一个微服务。

##### 实体（Entity）
1. 实体是看得到、摸得着的实实在在的业务对象，实体具有业务属性、业务行为和业务逻辑。
   - 有这样一类对象，它们拥有唯一标识符，且标识符在历经各种状态变更后仍能保持一致。对这些对象而言，重要的不是其属性，而是其延续性和标识，
   - 对象的延续性和标识会跨越甚至超出软件的生命周期。我们把这样的对象称为实体。
2. 领域模型中的实体是多个属性、操作或行为的载体。
   - 代码模型中，实体的表现形式是实体类，这个类包含了实体的属性和方法，通过这些方法实现实体自身的业务逻辑。
   - 这些实体类通常采用充血模型，与这个实体相关的所有业务逻辑都在实体类的方法中实现，跨多个实体的领域逻辑则在领域服务中实现。
3. 实体以 DO（领域对象）的形式存在，每个实体对象都有唯一的 ID。
   - 在领域模型映射到数据模型时，一个实体可能对应 0 个、1 个或者多个数据库持久化对象。大多数情况下实体与持久化对象是一对一。
   -- 在某些场景中，有些实体只是暂驻静态内存的一个运行态实体，它不需要持久化。比如，基于多个价格配置数据计算后生成的折扣实体。

##### 值对象（ValueObject）
值对象只是若干个属性的集合，只有数据初始化操作和有限的不涉及修改数据的行为，基本不包含业务逻辑。

1. 值对象的属性集虽然在物理上独立出来了，但在逻辑上它仍然是实体属性的一部分，用于描述实体的特征。
值对象本质上是一个集合，将“省、市、县和街道等属性”拿出来构成一个“地址属性集合”，这个集合就是值对象了。
实体和值对象是组成领域模型的基础单元。
2. 值对象嵌入到实体的话，有这样两种不同的数据格式，也可以说是两种方式，分别是属性嵌入的方式和序列化大对象（JSON）的方式。
3. 在领域建模时，我们可以将部分对象设计为值对象，保留对象的业务涵义，同时又减少了实体的数量；
4. 在数据建模时，我们可以将值对象嵌入实体，减少实体表的数量，简化数据库设计。
5. 有些场景中，地址会被某一实体引用，它只承担描述实体的作用，并且它的值只能整体替换，这时候你就可以将地址设计为值对象，比如收货地址。
    而在某些业务场景中，地址会被经常修改，地址是作为一个独立对象存在的，这时候它应该设计为实体，比如行政区划中的地址信息维护。	

##### 聚合（Aggregate）
领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确定这些领域对象在实现共同的业务逻辑时，能保证数据的一致性 聚合是数据修改和持久化的基本单元。
1. 聚合有一个聚合根和上下文边界，这个边界根据业务单一职责和高内聚原则，定义了聚合内部应该包含哪些实体和值对象，
2. 而聚合之间的边界是松耦合的。按照这种方式设计出来的微服务自然就是“高内聚、低耦合”的。
3. 聚合可以独立作为一个微服务，以满足版本的高频发布和极致的弹性伸缩能力

##### 聚合根（AggregateRoot）
聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致的问题
把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。
聚合之间通过聚合根ID关联引用，如果需要访问其他聚合的实体，就要先访问聚合根，
再导航到聚合内部实体，外部对象不能直接访问聚合内实体。

### DDD 分层架构模型
##### 用户接口层: 面向前端提供服务适配，面向资源层提供资源适配
interfaces（用户接口层）:它主要存放用户接口层与前端交互、展现数据相关的代码。前端应用用过这一层的接口，向应用服务获取所需的数据。这一层主要用来处理用户发送的Restful请求，
   解析用户输入的配置文件，并将数据传递给aoolication层。数据的组装、数据传输格式以及Facade接口等代码都会放在这一层目录里
1. interfaces的代码目录结构有：
    1. assembler：实现dto与领域对象之间的相互转换和数据交换。一般来说assembler与dto总是一同出现。
    2. dto：它是数据传输的载体，内部不存在任何业务逻辑。我们可以通过dto把内部的领域对象与外界隔离。
    3. facade：提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理。 
#### 应用层：实现服务组合和编排，适应业务流程快速变化的需求
applicaiton（应用层）：它主要存放应用层服务组合和编排的相关代码。应用服务向下基于微服务内的领域服务或外部微服务的应用服务完成服务的编排和组合， 
向上为用户接口层提供各种应用数据展现支持服务。应用服务和事件等代码会放在这一层目录里。
1. application的代码目录结构有：
    1. event（事件）：这层目录主要存放事件相关的代码，它包含两个子目录：publish和subscribe。
    publish主要存放事件发布相关代码，subscribe主要存放事件订阅相关代码（事件处理相关的核心业务逻辑在领域层实现）
    2. services（应用服务）：应用服务会对多个领域或外部应用服务进行封装、编排和组合，对外提供粗粒度的服务。应用服务主要实现服务组合和编排，
    是一段独立的业务逻辑。可以将所有应用服务放在一个应用服务类里，也可以把一个应用服务设计为一个应用服务类，以防应用服务类代码量过大。

#### 领域层: 实现领域的核心业务逻辑，聚集了领域模型的聚合、聚合根、实体、值对象、领域服务。
domain（领域层）: 它主要存放在领域层核心业务逻辑相关的代码。领域层可以包含多个聚合代码包，它们共同实现领域模型的核心业务逻辑。聚合以及聚合内的实体、
   方法、领域服务和事件等代码会放在这一层目录里。
1. domain的代码目录结构有：
    - aggregate（聚合）：它是聚合软件包的根目录，可以根据实际项目的聚合名称命名，比如权限聚合。在聚合内定义聚合根、实体和值对象以及领域服务之间的关系和边界。
      聚合内实现内聚的业务逻辑，它的代码可以独立拆分为微服务。
      以聚合为单位的代码放在一个包里的主要目的是为了业务内聚，而更大的目的是为了以后微服务业务之间聚合的重组。聚合之间清晰的代码边界，可以轻松地实现以聚合为单位的微服务重组，
      在微服务架构演进中有着重要作用。
    1. entity（实体）：它存放聚合根、实体、值对象以及工厂模式相关代码。实体类采用充血模型，同一实体相关的业务逻辑都在实体类代码中实现。跨实体的业务逻辑代码在领域服务中实现。
    2. event（事件）：它存放事件实体以及事件活动相关的业务逻辑代码。
    3. services（领域服务）：一个领域服务是多个实体组合出来的一段业务逻辑。可以将聚合内所有领域服务都放在一个领域服务类中，也可以把每一个领域服务设计为一个类。
      如果领域服务内的业务逻辑相对复杂，可以将一个领域服务设计为一个领域服务类，避免由于所有领域服务都放在一个领域服务类中，而出现代码臃肿的问题。
      领域服务封装多个实体或方法后向上层提供应用服务调用。
    4. repository（仓储）：它存放所在聚合的查询或持久化领域对象的代码，通常包括仓储接口和仓储实现方法。为了方便聚合的拆分和组合，一个聚合只用一个仓储。
#### 基础层：为各层提供基础资源服务。聚集底层资源相关的服务和能力。 
infrastructure（基础层）：它主要存放基础资源服务相关的代码，为其他各层提供的通用技术能力、三方软件、数据库服务、配置和基础资源服务于的代码都会放在这一层目录里。
1. infrastructure的代码目录结构有：
    1. config：主要存放配置相关代码
    2. utils：主要存放平台、开发框架、消息、数据库、缓存、文件、总线、网关、第三方类库、通用算法等基础代码。也可以为不同的资源类别建立不同的子目录。










-- 参考: https://blog.csdn.net/weixin_49526437/article/details/112553227