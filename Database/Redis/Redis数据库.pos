{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","title":"Redis数据库","leftChildren":[],"structure":"mind_right","root":true,"theme":"simple","children":[{"id":"4054cf7277e2","title":"Redis 简介","children":[{"id":"a6cc1f514e47","title":"官网","children":[{"id":"8b88b617a10d","title":"redis.io","parent":"a6cc1f514e47","children":[]},{"id":"d8f053ac82d7","title":"https://github.com/antirez/redis","children":[],"parent":"a6cc1f514e47"},{"id":"aa33d1a97832","title":"作者 Salvatore Sanfilippo","parent":"a6cc1f514e47","children":[],"note":"Redis 的作者，叫Salvatore Sanfilippo，来自意大利的西西里岛，居住在卡塔尼亚。目前供职于Pivotal公司。他使用的网名是antirez。\n"}],"parent":"4054cf7277e2"},{"id":"c466a62ed445","title":"NoSQL 介绍","children":[{"id":"755ca96a1b8b","title":"解决了什么问题","children":[{"id":"b5856b7abeab","title":"<font color=\"#c41230\">NoSQL 数据库的产生就是为了解决大规模数据集合<br>和多重数据种类带来的挑战，尤其是大数据应用难题</font><br>","style":{"border-color":"#f15a23","font-weight":"bold"},"parent":"755ca96a1b8b","children":[]}],"parent":"c466a62ed445"},{"id":"2cd231695547","title":"NoSQL 分类","children":[{"id":"a867a5e1ba75","title":"键值(Key-Value)存储数据库","parent":"2cd231695547","children":[{"id":"3dadad38e0d2","title":"概述","children":[],"parent":"a867a5e1ba75","note":"这一类数据库主要会使用到一个&lt;font color=&quot;red&quot;&gt;哈希表&lt;/font&gt;，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署。但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。举例如：Tokyo Cabinet/Tyrant， Redis， Voldemort， Oracle BDB。\n"},{"id":"750c47986974","title":"常见：Redis","parent":"a867a5e1ba75","children":[]}]},{"id":"6790f9ecf52c","title":"列存储数据库<br>","children":[{"id":"b014c9e7d62f","title":"概述","parent":"6790f9ecf52c","children":[],"note":"这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。如：Cassandra， HBase， Riak. \n"},{"id":"dc290410c587","title":"常见：Hbase","children":[],"parent":"6790f9ecf52c"}],"parent":"2cd231695547"},{"id":"c11d225f9ab0","title":"文档型数据库<br>","parent":"2cd231695547","children":[{"id":"e0e90630aeeb","title":"概述","children":[],"parent":"c11d225f9ab0","note":"文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可 以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。如：CouchDB， MongoDb. 国内也有文档型数据库SequoiaDB，已经开源。\n"},{"id":"b1622d8dc3a8","title":"常见：MongoDB","parent":"c11d225f9ab0","children":[]}]},{"id":"06ccfa193d74","title":"图形(Graph)数据库<br>","children":[{"id":"d4565d00a278","title":"概述","parent":"06ccfa193d74","children":[],"note":"文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可 以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。如：CouchDB， MongoDb. 国内也有文档型数据库SequoiaDB，已经开源。\n"},{"id":"4c7ccb115404","title":"常见：Neo4J","children":[],"parent":"06ccfa193d74"}],"parent":"2cd231695547"}],"parent":"c466a62ed445"},{"id":"7dff655acb3e","title":"适用场景","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(255, 83, 92)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[{"id":"78205c096498","title":"1. 数据模型比较简单","children":[],"parent":"7dff655acb3e"},{"id":"bd893c629046","title":"2. 需要灵活性更强的 IT 系统","children":[],"parent":"7dff655acb3e"},{"id":"e2b9a2951ff5","title":"3. 对数据库性能要求较高","children":[],"parent":"7dff655acb3e"},{"id":"2166f94e79a4","title":"4. 不需要高度的数据一致性","children":[],"parent":"7dff655acb3e"},{"id":"92973ef7e035","title":"5. 对于给定 Key，比较容易映射复杂的环境","children":[],"parent":"7dff655acb3e"}],"parent":"c466a62ed445"}],"parent":"4054cf7277e2","note":"NoSQL ，泛指非关系型的数据库。随着互联网 web2.0 网站的新奇，传统的关系数据库在应付 web2.0 网站特别是超大规模和高并发的 SNS 类型的 web2.0 纯动态网站已经吏部重新，暴露除了很多难以客服的问题，而非关系型的数据库则是由于其本身特点得到了非常迅速的发展。 &lt;font color=&quot;red&quot;&gt;**NoSQL 数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题** &lt;/font&gt;"},{"id":"6458046ac7d1","title":"关系型数据库","parent":"4054cf7277e2","children":[{"id":"694355f64531","title":"关系型数据库需要对：表与表之间建立关联关系","parent":"6458046ac7d1","children":[]}]},{"id":"7258bf055f22","title":"Redis 与其他 Key-Value 缓存产品对比：","parent":"4054cf7277e2","children":[{"id":"c070e4f55adc","title":"1. Redis 支持数据的持久化， 可以将数内存中的数据保存在磁盘中，<br>重启的时候可以再次加载进行适用<br>","children":[],"parent":"7258bf055f22"},{"id":"1e97b52998e8","title":"2. Redis 不仅仅支持简单的 key-value 类型的数据，<br>同时还提供 list, set，zset, hash等数据结构的存储<br>","children":[],"parent":"7258bf055f22"},{"id":"fde85354942f","title":"3. Redis 支持数据的备份，集群等高可用功能","children":[],"parent":"7258bf055f22"}]},{"id":"c7bfe5fc3ac1","title":"Redis 特点","children":[{"id":"f20433547810","title":"1. 速度快","parent":"c7bfe5fc3ac1","children":[{"id":"a56dcc680b8d","title":"读取速度 11w/秒","parent":"f20433547810","children":[]},{"id":"ad156cd3d878","title":"写的速度是 8.1w/秒","parent":"f20433547810","children":[]}],"note":"1.  底层采用 C语言编写；\n2. 基于内存存储。"},{"id":"080337a0eff4","title":"2. 提供丰富的数据类型","children":[{"id":"334e462a8918","title":"String","parent":"080337a0eff4","children":[]},{"id":"407928d19b7c","title":"List","parent":"080337a0eff4","children":[]},{"id":"068b8941ffcd","title":"Set","parent":"080337a0eff4","children":[]},{"id":"8ed2dbff32f0","title":"ZSet","parent":"080337a0eff4","children":[]},{"id":"1de4b53d0705","title":"Hash","parent":"080337a0eff4","children":[]}],"parent":"c7bfe5fc3ac1"},{"id":"3b62e240570e","title":"3. 具备原子性","parent":"c7bfe5fc3ac1","children":[{"id":"dc94c05ea782","title":"Redis 所有操作都是原子性，意思就是要么执行成功要么执行失败完全不执行。<br>单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI&nbsp; 和 EXEC 指令包起来","parent":"3b62e240570e","children":[]}]},{"id":"5fac7951c220","title":"4. 丰富的特征","parent":"c7bfe5fc3ac1","children":[{"id":"e867c2f1ae13","title":"Redis 还支持 publish/subscribe, 通知，key&nbsp; 过期等特征","parent":"5fac7951c220","children":[]}]},{"id":"3c52177c638f","title":"总结","children":[],"parent":"c7bfe5fc3ac1","note":"Redis 是一个简单的，高效的，分布式的，基于内存缓存工具，架设好服务其后，通过网络链接（类似数据库），提供Key-Value 式缓存服务。\n简单， 是Redis 的突出特色。\n简单可以保证核心功能的稳定和优异。"}],"parent":"4054cf7277e2"},{"id":"2a15537f21dc","title":"小总结","children":[{"id":"45719ee2e2f5","title":"优点","children":[],"parent":"2a15537f21dc","note":"**优点：**\n1. 丰富的数据结构\n2. 高速读写， Redis 使用自己实现的分离器，代码量很短，没有使用  lock (MySQL)因此效率非常高。\n"},{"id":"185356e9c09d","title":"缺点","parent":"2a15537f21dc","children":[],"note":"**缺点；**\n1.  持久化， Redis 直接将数据存储到内存中，要将数据保存到磁盘上，Redis 可以使用两种方式实现持久化过程，定时快照（snapshot）；每间隔一段时间将整个数据库写到磁盘上，每次均是全部数据，代价非常高，第二种方式基于语句追加（AOF）只追踪变化的数据，但是追加的log 可能过大，同时所有的操作均重新执行一遍，回复速度慢。\n2. 消耗内存，占用内存过高"}],"parent":"4054cf7277e2","note":"Redis 是一个单 key 存入 512M 大小\nRedis  支持多种类型的数据结构（String，List，Hash，Set ， ZSet）\nRedis 是单线程 原子性\nRedis 可以持久化，因为使用了 RDB 和 AOF 机制\nRedis 支持集群， 而Redis支持 库 0-15 个库\nRedis 还可以做消息队列 比如聊天室 MI\n\n\n企业级开发中： 可以做数据库、缓存（热点数据（经常需要被查询，但是不经常被修改或者删除的数据）和消息中间件等大部分共恩感）\n\n**优点：**\n1. 丰富的数据结构\n2. 高速读写， Redis 使用自己实现的分离器，代码量很短，没有使用  lock (MySQL)因此效率非常高。\n\n**缺点；**\n1.  持久化， Redis 直接将数据存储到内存中，要将数据保存到磁盘上，Redis 可以使用两种方式实现持久化过程，定时快照（snapshot）；每间隔一段时间将整个数据库写到磁盘上，每次均是全部数据，代价非常高，第二种方式基于语句追加（AOF）只追踪变化的数据，但是追加的log 可能过大，同时所有的操作均重新执行一遍，回复速度慢。\n2. 消耗内存，占用内存过高"}],"parent":"root","icons":[{"text":"&#xe67a","index":"0","color":"rgb(191, 30, 27)","name":"priority"}],"note":"&lt;font color=&quot;red&quot;&gt;Redis 是完全开源的，遵守 BSD 协议，是一个高性能（NoSQL）的 Key-Value 数据库。&lt;/font&gt;\nRedis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。","collapsed":false},{"id":"005214a53d1c","title":"Redis 的安装/配置","parent":"root","children":[{"id":"eb6499e3b9e0","title":"Mac 安装","children":[{"id":"b804c73fe922","title":"brew安装命令： brew install redis","children":[],"parent":"eb6499e3b9e0"}],"parent":"005214a53d1c"},{"id":"a748ebae60a5","title":"Linux(CentOS)","parent":"005214a53d1c","children":[{"id":"6582cf55c840","title":"下载地址：http://download.redis.io/releases/redis-5.0.8.tar.gz","children":[],"parent":"a748ebae60a5"},{"id":"5faa2dc86ec8","title":"Redis安装","parent":"a748ebae60a5","children":[{"id":"74628f2b286d","title":"gcc 安装&nbsp;","children":[{"id":"b9462de4915b","title":"yum -y install gcc automake autoconf libtool make","parent":"74628f2b286d","children":[]},{"id":"2bd13c26814e","title":"注意：运行 yum 时出现 /var/run/yum.pid 已被锁定， PID 为 xxx 的另一个程序正在运行的问题解决","parent":"74628f2b286d","children":[]},{"id":"7fb6251b0a9a","title":"rm -rf /var/run/yum.pid","children":[],"parent":"74628f2b286d"}],"parent":"5faa2dc86ec8"},{"id":"54c69ebfa325","title":"redis 安装","children":[{"id":"c408a9b2bb3a","title":"1. wget&nbsp;http://download.redis.io/releases/redis-5.0.8.tar.gz","parent":"54c69ebfa325","children":[]},{"id":"03f1be4111cf","title":"2. 解压：tar -zxvf redis-5.0.8.tar.gz","parent":"54c69ebfa325","children":[]},{"id":"774b90688c48","title":"3. 编译：make 或 <font color=\"#c41230\"><b>make MALLOC=libc</b></font>","parent":"54c69ebfa325","children":[]},{"id":"b586c519b9b0","title":"4. 安装：make PREFIX=/usr/local/redis install","parent":"54c69ebfa325","children":[]}],"parent":"5faa2dc86ec8"}]},{"id":"e53392ef9970","title":"启动命令","children":[{"id":"a3be1c6bda7f","title":"1. 进入目录： cd /user/local/redis/bin","parent":"e53392ef9970","children":[]},{"id":"d2a108a61908","title":"2. 启动服务： ./redis-server &amp;","children":[],"parent":"e53392ef9970"},{"id":"686532e7eac9","title":"3. 客户端访问：./redis-cli","children":[{"id":"a2d1aea0ac5c","title":"<font color=\"#c41230\"><b>redis-cli -h IP 地址 -p 端口</b></font>","parent":"686532e7eac9","children":[]},{"id":"7732f8d43173","title":"退出客户端 control + C","children":[],"parent":"686532e7eac9"}],"parent":"e53392ef9970"},{"id":"fa7d83c3efdd","title":"4. PING 命令","children":[],"parent":"e53392ef9970"}],"parent":"a748ebae60a5"}],"icons":[{"text":"&#xe67a","index":"0","name":"priority"}],"collapsed":false},{"id":"c36d45b28fb2","title":"配置文件详解 redis.conf","children":[{"id":"1a0b92fd7e87","title":"说明","children":[{"id":"a56c46901aec","title":"Redis 的配置文件 位于Redis 的安装目录下， <br>文件名为 redis.conf ( Windows 名为 redis.windows.conf)<br>","parent":"1a0b92fd7e87","children":[]}],"parent":"c36d45b28fb2"},{"id":"aababf0d8c01","title":"配置Redis","parent":"c36d45b28fb2","children":[{"id":"3cc59953434c","title":"1. 在安装包的根目录下找到 <b><font color=\"#c41230\">redis.conf </font></b>文件","children":[],"parent":"aababf0d8c01"},{"id":"b131af4f5722","title":"2. 复制配置文件安装目录","parent":"aababf0d8c01","children":[{"id":"76ea86ddd5cf","title":"cp redis.conf /usr/local/redis","children":[],"parent":"b131af4f5722"}]}]},{"id":"61e2e46d2dac","title":"配置文件解读","children":[{"id":"90e078492d8a","title":"查看配置文件 命令","parent":"61e2e46d2dac","children":[{"id":"d7175e7e5651","title":"less -mN redis.conf","parent":"90e078492d8a","children":[]}]},{"id":"35d1cb35d965","title":"1. Redis 默认不是以守护进程的方式运行，<br>可以通过该配置项修改，使用 yes 启用守护进程<br>","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(80, 194, 139)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[{"id":"d21d1b18141f","title":"<font color=\"#c41230\"><b>daemonize no</b></font>","style":{"border-color":"#c41230"},"children":[],"parent":"35d1cb35d965"}],"parent":"61e2e46d2dac"},{"id":"4d59123cd8ab","title":"2. 当 Redis 以守护进程方式运行时， Redis 默认会把 pid 写入 <br>/var/run/redis.pid 文件，可以通过pridfile 指定<br>","parent":"61e2e46d2dac","children":[{"id":"28f6af50b2a0","title":"<font color=\"#c41230\"><b>pidfile/var/run/redis.pid</b></font>","parent":"4d59123cd8ab","children":[]}]},{"id":"b6a52e237eba","title":"3. 指定 Redis 监听端口默认为 6379， 为什么选用6379 为默认端口，<br>因为 6379 在手机按键上 MERZ 对应编码，而 MERZ 取子意大利歌女 Alessia Merz 的名字<br>","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[{"id":"02a8b36d15b7","title":"<b><font color=\"#c41230\">port 6379</font></b>","parent":"b6a52e237eba","children":[]}],"parent":"61e2e46d2dac"},{"id":"529606aeac27","title":"4. 绑定的主机地址","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(80, 194, 139)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"61e2e46d2dac","children":[{"id":"75ad073c08c8","title":"<b><font color=\"#c41230\">bind 127.0.0.1</font></b>","style":{"border-color":"#c41230","font-weight":"bold"},"parent":"529606aeac27","children":[]}]},{"id":"511110e6241c","title":"5. 当客户端闲置时间多长后关闭联机，如果指定为0，表示关闭该功能","children":[{"id":"34da0f509e05","title":"timeout 300","parent":"511110e6241c","children":[]}],"parent":"61e2e46d2dac"},{"id":"ea4e0afde572","title":"6. 指定日志记录级别， Redis 总共支持四个级别：debug, verbose, notice, warning，默认为verbose&nbsp;","parent":"61e2e46d2dac","children":[{"id":"66f17df13c9a","title":"loglevel verbose","children":[],"parent":"ea4e0afde572"}]},{"id":"52063db0aef5","title":"7. 日志记录方式， 默认标准输出，如果配置 Redis 为守护进程方式运行，<br>而这里有配置为日志记录方式为标准输出，则日志将会发送给 /dev/null<br>","children":[{"id":"d4818724e587","title":"logfiel stdout","children":[],"parent":"52063db0aef5"}],"parent":"61e2e46d2dac"},{"id":"0d85ad62462e","title":"8.设置数据库的数量， 默认数据库为0， 可以使用 SELECT &lt;dbid&gt; 命令在链接指定数据库Id","parent":"61e2e46d2dac","children":[{"id":"ff3d47abbc23","title":"database 16","parent":"0d85ad62462e","children":[]}]},{"id":"71cc8260d7e1","title":"9. 指定多长时间内，有多少个更新操作，就会将数据同步到数据文件，可以多个条件配合。","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(80, 194, 139)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"61e2e46d2dac","children":[{"id":"37b842260524","title":"save &lt;seconds&gt; &lt;changes&gt;","parent":"71cc8260d7e1","children":[]},{"id":"7da8d271f69f","title":"Redis 提供了三个条件","parent":"71cc8260d7e1","children":[{"id":"4c0ed73aa26d","title":"save 900 1","parent":"7da8d271f69f","children":[]},{"id":"4f5d0bb29a0f","title":"save 300 10","children":[],"parent":"7da8d271f69f"},{"id":"6d8284d07488","title":"save 60 10000","parent":"7da8d271f69f","children":[]}],"note":" 分别表示 900 秒（15分钟）内有一个更改， 300 秒（5分钟）内有10个更改，60秒内鱼哦 10000个更改。\n"}]},{"id":"9d47527c76a2","title":"10. 指定存储至本地数据库时否压缩数据，默认为 yes , Redis 采用 LZF 压缩，<br>如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变得巨大<br>","parent":"61e2e46d2dac","children":[{"id":"3465ade6679a","title":"rdbcompression yes","children":[],"parent":"9d47527c76a2"}]},{"id":"675e9799f714","title":"11. 指定本地数据库文件名，默认为 dump.rdb","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(80, 194, 139)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[{"id":"e150ccfa0694","title":"dbfilename dump.rdb","children":[],"parent":"675e9799f714"}],"parent":"61e2e46d2dac"},{"id":"a3aba4eb130d","title":"12. 指定本地数据库存放目录","children":[{"id":"820aa986d5b8","title":"dir ./","children":[],"parent":"a3aba4eb130d"}],"parent":"61e2e46d2dac"},{"id":"1e81cc1b6a7e","title":"13. 设置本地 slav 服务时， 设置master 服务的IP地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步","children":[{"id":"bf729122f1f1","title":"slaveof &lt;masterip&gt; &lt;masterport&gt;","parent":"1e81cc1b6a7e","children":[]}],"parent":"61e2e46d2dac"},{"id":"a585121e3a18","title":"14. 当 master 服务设置了密码保护时， slav 服务链接 master 的密码","children":[{"id":"69361aecc994","title":"masterauth &lt;master-password&gt;","parent":"a585121e3a18","children":[]}],"parent":"61e2e46d2dac"},{"id":"7b63441465ba","title":"15. 设置 Redis 链接密码，如果设置了链接密码，客户端在链接 Redis 时需要通过 <br>AUTH &lt;password&gt; 命令提供密码，默认关闭<br>","parent":"61e2e46d2dac","children":[{"id":"cf4b3b4b3dea","title":"requirepass foobared","parent":"7b63441465ba","children":[]}]},{"id":"98d1036c4e61","title":"16. 设置同一时间最大客户端连接数，默认无限制， Redis 可以同时打开的客户端连接数为<br>进程可以打开的最大文件描述符数量， 如果设置为 maxclients 0,&nbsp; 表示不限制，当客户端连接数到达限制时， <br>Redis 会关闭新的链接并想客户端返回 max number of clients reached 错误信息<br>","children":[{"id":"a298447e51c3","title":"maxclients 128","parent":"98d1036c4e61","children":[]}],"parent":"61e2e46d2dac"},{"id":"d1d1b910f51e","title":"17. 指定Redis 最大内存限制，Redis 在启动的时候会把数据加载到内存中，达到最大内存后， Redis 会先<br>清除已经到期或即将到期的 Key ， 在此处理方法之后，仍然到达最大的内存设置，将无法在进行写入操作，<br>但仍然可以进行读取操作，Redis 新的 vm 机制， 会把 Key 放入内存， Value 会放入 swap 区<br>","parent":"61e2e46d2dac","children":[{"id":"a8a57369d9f3","title":"maxmemory &lt;bytes&gt;&nbsp;","parent":"d1d1b910f51e","children":[]}]},{"id":"d96e1c36b351","title":"18. 指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，<br>可能会在断电时导致一段时间内的数据丢失。因为 Redis 本身同步数据文件时按上面 save 条件来进行同步的， <br>所以一段时间内只存在内存中默认为 no<br>","children":[{"id":"2738ab4313a4","title":"appendonly no","children":[],"parent":"d96e1c36b351"}],"parent":"61e2e46d2dac"},{"id":"9f9ac0ed8783","title":"19. 指定更新日志文件名，默认为 appendonly.aof","parent":"61e2e46d2dac","children":[{"id":"67ba9c2cad48","title":"appedfilename appendonly.aof","parent":"9f9ac0ed8783","children":[]}]},{"id":"9d12a93cc1ff","title":"20. 指定更新日志条件，一共有3个可选值","parent":"61e2e46d2dac","children":[{"id":"6e1054bc8543","title":"no 表示等操作系统进行数据缓存同步到磁盘（快）","parent":"9d12a93cc1ff","children":[]},{"id":"ac4c990145e6","title":"always 表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）","children":[],"parent":"9d12a93cc1ff"},{"id":"e33418a235e9","title":"everyses: 表示每秒同步一次（折中，默认值）","parent":"9d12a93cc1ff","children":[]},{"id":"b71d83fd21bb","title":"appendfsync everysec","parent":"9d12a93cc1ff","children":[]}]},{"id":"eb2e0b0f66f6","title":"21. 指定是否启用虚拟机内存机制，默认为 no , 简单的介绍一下，VM 机制将数据分页存放，<br>由 Redis 访问量较少的页冷数据 swap 到磁盘上，访问最多的页面是由磁盘自动切换出到内存中（后面会分析到）<br>","parent":"61e2e46d2dac","children":[{"id":"284998313929","title":"vm-enabled no","parent":"eb2e0b0f66f6","children":[]}]},{"id":"b4c5cec1b6c9","title":"22. 虚拟机内存文件路径，默认值为 /tmp/redis.swap,&nbsp; 不可多个 Redis 实例共享","children":[],"parent":"61e2e46d2dac"},{"id":"1bbc28bbf49a","title":"23. 将所有大于 vm-max-memory 的数据存如虚拟机内存，无论 vm-max-memory 设置多小, <br>所有索引数据都是内存存储的 （Redis 的索引数据就是 keys） 也就是说，<br>当 vm-max-memory 设置为 0 的时候其实所有 value 都存在磁盘中， 默认值为 0<br>","parent":"61e2e46d2dac","children":[{"id":"96e9aaba8daf","title":"vm-max-memory 0","children":[],"parent":"1bbc28bbf49a"}]},{"id":"ef01de782918","title":"24. Redis swap 文件分成了多个 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，&nbsp;<br>vm-page-size 是要根据存储的数据大小来设定的， 作则建议如果存储很多小对象，page 大小最好设置为32 或者 64 bytes; 如果存储很大对象， <br>则可以使用更大的 page , 如果不确定，就是用默认值<br>","parent":"61e2e46d2dac","children":[{"id":"de2c25c82b42","title":"vm-page-size 32","parent":"ef01de782918","children":[]}]},{"id":"1c9255d8dd1c","title":"25. 设置 swap 文件的page 数量， 由于页表（一种表示页面空闲或使用 bitmap）s是放在内存中的，在磁盘上每 8 个pages 将消耗1bytes 内存<br>","children":[{"id":"5514ae359464","title":"vm-pages 134217728","parent":"1c9255d8dd1c","children":[]}],"parent":"61e2e46d2dac"},{"id":"3e3e82d0bbc8","title":"26.设置访问 swap 文件的线程数， 最好不要超过机器的核数， 如果设置为0， 那么对swap 文件的操作都是串行的，<br>可能会造成比较长的时间的延迟，默认值为：4","parent":"61e2e46d2dac","children":[{"id":"d038e4ce2933","title":"vm-max-threads 4","parent":"3e3e82d0bbc8","children":[]}]},{"id":"991e30f8e2fc","title":"27. 设置在向可兑换应答时，是否把较小的包含合并为一个发送，默认开启","children":[{"id":"1e52085dbe35","title":"glueoutputbuf yes","parent":"991e30f8e2fc","children":[]}],"parent":"61e2e46d2dac"},{"id":"d14f8ae37a55","title":"28.指定在超过一定数量或者最大元素超过某临界值时，采用一种特殊的hash 算法","parent":"61e2e46d2dac","children":[{"id":"e7eff1aac727","title":"hash-max-zipmap-entries 64","parent":"d14f8ae37a55","children":[]},{"id":"d421f9d14a88","title":"hash-max-zipmap-value 512","parent":"d14f8ae37a55","children":[]}]},{"id":"12d8afaba04d","title":"29. 指定激活重置哈希，默认开启（后面介绍 Redis 的哈希算法的时候具体介绍）","children":[{"id":"a53246d17c00","title":"activerehashing yes","parent":"12d8afaba04d","children":[]}],"parent":"61e2e46d2dac"},{"id":"4af4b7a8a01d","title":"30. 指定包含其他的配置文件，可以在同一个主机上多个 Redis 实例之间使用同一份配置文件， <br>而同时各个实例又拥有自己的特定配置文件<br>","parent":"61e2e46d2dac","children":[{"id":"6b11f1f5a014","title":"include /path/to/local.conf","parent":"4af4b7a8a01d","children":[]}]},{"id":"9e6db3e84276","title":"31.&nbsp; redis 作为优秀的中间件缓存，时长会存储大量的数据，即使采取了集群部署来动态拓容，<br>也应该即时的整理内存，维持系统性能（如果数据一直新增，内存则很快会占满）<br>","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(80, 194, 139)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[{"id":"fd1b6393e619","title":"两种解决方案","parent":"9e6db3e84276","children":[{"id":"dd7e1781ca9f","title":"1. 为数据设置超时时间","parent":"fd1b6393e619","children":[{"id":"774b091ce785","title":"设定内存，建议不要超过1 G 256-512M","children":[],"parent":"dd7e1781ca9f"}]},{"id":"37426a12c434","title":"2. 采用 LRU算法动态不用的数据删除","children":[{"id":"085ef6383512","title":"1. volatile-lru","children":[{"id":"2eb40a78b0e2","title":"设定超时时间的数据中，删除最不常用的数据","parent":"085ef6383512","children":[]}],"parent":"37426a12c434"},{"id":"06955f40097d","title":"2.&nbsp;allkeys-lru","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(80, 194, 139)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"37426a12c434","children":[{"id":"3e292a4db5d0","title":"查询所有的key 中最不常使用的数据进行删除，这是应用最广泛的策略","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[],"parent":"06955f40097d"}]},{"id":"831a5c373dd7","title":"3.&nbsp;volatile-random","children":[{"id":"b94094effd0b","title":"在已经设定了超时的数据中随机删除","children":[],"parent":"831a5c373dd7"}],"parent":"37426a12c434"},{"id":"4081465ed2ab","title":"4.&nbsp;allkeys-random","parent":"37426a12c434","children":[{"id":"161e3eefc17c","title":"查询所有的 key 之后随机删除","children":[],"parent":"4081465ed2ab"}]},{"id":"ee78d3118f72","title":"5. volatile-ttl","parent":"37426a12c434","children":[{"id":"ee09900f5ff2","title":"查询全部设定超时时间的数据，追后马上排序，将马上将要过期的数据进行删除操作","children":[],"parent":"ee78d3118f72"}]},{"id":"bb67cbeb4a54","title":"6.&nbsp;noeviction (默认)","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(255, 83, 92)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"37426a12c434","children":[{"id":"feadf3642165","title":"如果设置为该属性，则不会进行删除操作，如果内存溢出则报错返回","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[],"parent":"bb67cbeb4a54"}]},{"id":"4a1b9a90a102","title":"7. volatile-lfu","children":[{"id":"3640effb0a69","title":"从所有配置了过期的时间的键中驱逐使用频率最少的键","parent":"4a1b9a90a102","children":[]}],"parent":"37426a12c434"},{"id":"72a477097c1f","title":"8. allkeys-lfu","parent":"37426a12c434","children":[{"id":"c5bb55c6bd1f","title":"从所有键中驱逐使用频率最少的键","parent":"72a477097c1f","children":[]}]}],"parent":"fd1b6393e619","note":"内存管理的一种页面置换算法，对于在内存中，但又不用的数据块（内存块）叫做LRU， 操作系统会更具哪些数据属于 LRU而将其移除内存而腾出空间来加载另外的数据。"}]}],"parent":"61e2e46d2dac"}],"parent":"c36d45b28fb2","collapsed":false},{"id":"08be108fe863","title":"自定义配置","parent":"c36d45b28fb2","children":[{"id":"fc0b22e6973f","title":"1. 进入安装目录 cd /usr/local/redis","children":[],"parent":"08be108fe863"},{"id":"fd2d3cc76bc3","title":"2. 编辑 redis.conf&nbsp; vim redis.conf","parent":"08be108fe863","children":[]},{"id":"bc90a804a306","title":"3. 设置默认必须修改的参数","children":[{"id":"4fb50329d4cb","title":"1. daemonize no 修改为 daemonize yes","parent":"bc90a804a306","children":[]},{"id":"e6a12b809d05","title":"2. 注释掉 bind 127.0.0.1","children":[],"parent":"bc90a804a306"},{"id":"67f87461a6d7","title":"3. requirepass 设置密码","parent":"bc90a804a306","children":[]}],"parent":"08be108fe863","note":"Redis 采用的单进程多线程的模式，当redis.conf 设置成 yes 代表开启守护进程模式。在该模式下，redis 会在后台进行，并将进程 pid 写入 redis.conf 选项  pidfile 设置的文件中。 此时 redis 将一直运行，除非手动kill 该进程，只有当 daemonize 现象设置为 no 时， 当界面进入 redis 的命令行界面，exit 强制退出或古纳比链接工具 （putty , xshell 等）都会导致 redis 进程退出。\n\n** 服务端开发的大部分应用都是采用后台运行的模式 **"},{"id":"82693aeec189","title":"4. 启动 Redis 命令","parent":"08be108fe863","children":[{"id":"f0df966bb41a","title":"1.&nbsp;./bin/redis-server redis.conf ","children":[],"parent":"82693aeec189"},{"id":"e41eef9b8a86","title":"2. 查询进程：&nbsp;ps -ef | grep redis","children":[],"parent":"82693aeec189"},{"id":"4c5acb7a6ac4","title":"3. 客户端登录：./bin/redis-cli -h 127.0.0.1 -p 16379 -a Iredis8Pwd","parent":"82693aeec189","children":[{"id":"6237bc0d1970","title":"命令模板： redis-cli -h host -p port -a password","children":[],"parent":"4c5acb7a6ac4"},{"id":"63a20d675732","title":"<font color=\"#c41230\"><b>redis-cli -h host -p 端口 -a 密码</b></font>","children":[],"parent":"4c5acb7a6ac4"}],"collapsed":true}]}],"collapsed":false}],"parent":"005214a53d1c","icons":[{"text":"&#xe625","index":"1","color":"rgb(48, 191, 191)","name":"priority"}],"collapsed":false},{"id":"69a517eb2fd1","title":"Redis 的关闭","parent":"005214a53d1c","children":[{"id":"b9775d8a944a","title":"1. 断电、非正常关闭（容易丢失数据）","parent":"69a517eb2fd1","children":[{"id":"79c6337bb5f9","title":"查询 PID&nbsp; ps -ef | grep redis","parent":"b9775d8a944a","children":[]},{"id":"d50784a83cf4","title":"kil -9 PID","parent":"b9775d8a944a","children":[]}],"collapsed":true},{"id":"d9a3c9650bf6","title":"2. 正常关闭，保存数据","parent":"69a517eb2fd1","children":[{"id":"a2ad6065b316","title":"./bin/redis-cli shutdown","parent":"d9a3c9650bf6","children":[]},{"id":"6bb6ac3b7590","title":"如果设置了密码需要先通过客户端登录，然后执行shutdown 命令即可关闭服务","children":[],"parent":"d9a3c9650bf6"}],"collapsed":true}],"icons":[{"text":"&#xe62a","index":"2","color":"rgb(255, 159, 26)","name":"priority"}],"collapsed":false},{"id":"e8c5688d81be","title":"Redis 常用命令","children":[{"id":"f4ae895bacd3","title":"用命令管理 Redis 的键","children":[],"parent":"e8c5688d81be"},{"id":"da452b7ebf49","title":"DEL key","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"e8c5688d81be","children":[{"id":"4c7669bdfb3b","title":"该命令用于在 key&nbsp; 存在时删除 key","children":[],"parent":"da452b7ebf49"}]},{"id":"3b038ca0d0c3","title":"DUMP&nbsp; key","children":[{"id":"7d0fa7b936f4","title":"序列化给定 key ，返回被序列化的值","parent":"3b038ca0d0c3","children":[]}],"parent":"e8c5688d81be"},{"id":"4b26d725669c","title":"EXISTS key","parent":"e8c5688d81be","children":[{"id":"d291ee116f9b","title":"检查给定的 key 是否存在","children":[],"parent":"4b26d725669c"}]},{"id":"7352c72bdbbd","title":"EXPIRE key seconds","children":[{"id":"497a7888d7cc","title":"为给定的 key 设置过期时间（以毫秒计算）","children":[],"parent":"7352c72bdbbd"}],"parent":"e8c5688d81be"},{"id":"7f4a97ee7491","title":"PEXPIRE key&nbsp; milliseconds","parent":"e8c5688d81be","children":[{"id":"23136d9a2f18","title":"设置 key 的过期时间以毫秒计","parent":"7f4a97ee7491","children":[]}]},{"id":"f45b25388cfb","title":"TTL Key","children":[{"id":"3a1c50d29595","title":"以秒为单位，返回给定 key 的剩余的过期时间。","parent":"f45b25388cfb","children":[{"id":"e630b698b19d","title":"-1 代表永久有效","style":{"border-radius":"20px","color":"rgb(242, 154, 102)","background-color":"rgb(255, 255, 255)","border-style":"solid","border-color":"rgb(242, 154, 102)","border-width":"2px"},"parent":"3a1c50d29595","children":[]},{"id":"4d0554dbd8b0","title":"-2 代表无效的键","style":{"border-radius":"20px","color":"rgb(242, 154, 102)","border-style":"solid","background-color":"rgb(255, 255, 255)","border-color":"rgb(242, 154, 102)","border-width":"2px"},"parent":"3a1c50d29595","children":[]}]}],"parent":"e8c5688d81be"},{"id":"4c598de4a658","title":"PTTL key","parent":"e8c5688d81be","children":[{"id":"83cd3ef17720","title":"&nbsp;以好面为单位返回 key 的剩余过期的时间","children":[],"parent":"4c598de4a658"}]},{"id":"847df2dc7230","title":"PERSIST&nbsp; key","children":[{"id":"9b603cb7c760","title":"移除 key 的过期时间，key 将持久保持","parent":"847df2dc7230","children":[]}],"parent":"e8c5688d81be"},{"id":"403cf6b41486","title":"KEYS pattern","parent":"e8c5688d81be","children":[{"id":"0e5cecc28af2","title":"查找符合所有给定模式（pattern）的 key.","children":[],"parent":"403cf6b41486"},{"id":"5d9bb0580aee","title":"key 通配符 获取所有与 pattern 匹配的 key, 返回所有与该匹配","children":[],"parent":"403cf6b41486"},{"id":"c64bdcf1a867","title":"通配符","children":[{"id":"8eacc272dd2a","title":"&nbsp;* 代表所有","children":[],"parent":"c64bdcf1a867"},{"id":"0d3bed8a4324","title":"？ 代表匹配一个字符","parent":"c64bdcf1a867","children":[]}],"parent":"403cf6b41486"}]},{"id":"0808be3c873d","title":"RANDOMKEY (redis 5)","style":{"border-radius":"20px","color":"rgb(242, 154, 102)","background-color":"rgb(255, 255, 255)","border-style":"solid","border-color":"rgb(242, 154, 102)","border-width":"2px"},"children":[{"id":"df938e3381d5","title":"从当前数据库中随机返回一个key","children":[],"parent":"0808be3c873d"}],"parent":"e8c5688d81be"},{"id":"97a1edfd332d","title":"RENAME key newkey","parent":"e8c5688d81be","children":[{"id":"453c16b7dbfa","title":"修改 key 的名称","children":[],"parent":"97a1edfd332d"}]},{"id":"f7cea4403424","title":"MOVE key db","parent":"e8c5688d81be","children":[{"id":"b2b8b077d0d9","title":"将当前数据的 key 移动到指定的数据 db 当中","children":[],"parent":"f7cea4403424"}]},{"id":"174e48feac32","title":"TYPE key&nbsp;","parent":"e8c5688d81be","children":[{"id":"115346800857","title":"返回 key 所存储的值的类型","children":[],"parent":"174e48feac32"}]}],"parent":"005214a53d1c","icons":[{"text":"&#xe635","index":"3","color":"rgb(99, 171, 247)","name":"priority"}],"note":"Redis 命令用于在 Redis 服务器上执行操作，要在 Redis 服务商执行命令需要个 Redis 客户端。Redis 客户端我们之前下载的 Redis 安装包中。\n\n&lt;font color=&quot;red&quot;&gt; Redis 支持五种数据类型：string (字符串)，hash (哈希)， list (列表)， set （集合），以及 zset （sorted set: 有序集合）。&lt;/font&gt;\n\n","collapsed":false},{"id":"05a4eb07e885","title":"命令应用场景","parent":"005214a53d1c","children":[{"id":"9618f91fdcca","title":"<font color=\"#c41230\"><b>EXPIR key seconds</b></font>","children":[{"id":"8f54c5a53017","title":"1. 限时优惠活动","children":[],"parent":"9618f91fdcca"},{"id":"33e7825a7da4","title":"2. 网站数据缓存（对于一些需要定时更新的数据，例如：积分排榜榜）","parent":"9618f91fdcca","children":[]},{"id":"46c9cb1f9a32","title":"3. 手机验证码","children":[],"parent":"9618f91fdcca"},{"id":"6ec5dc571613","title":"4. 限制网站访客频率（例如：1分钟最多访问 10次）","parent":"9618f91fdcca","children":[]}],"parent":"05a4eb07e885"}],"icons":[{"text":"&#xe626","index":"4","color":"rgb(113, 203, 45)","name":"priority"}],"collapsed":false},{"id":"a2661373f4d2","title":"Key 的命名建议","children":[{"id":"b87208ef5630","title":"<b><font color=\"#c41230\">0. 单个key 最大存入数据 为512M 大小</font></b>","style":{"font-weight":"bold"},"children":[],"parent":"a2661373f4d2"},{"id":"cb208c2e98a6","title":"1. key 不要太长，尽量不要超过 1024 字节，这不仅消耗内存，而且会降低查找的效率；","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"a2661373f4d2","children":[]},{"id":"eaab00a76595","title":"2. key 也不要太短，太短的话，key 的可读性会降低；","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(80, 194, 139)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[],"parent":"a2661373f4d2"},{"id":"a7c10c460563","title":"3. 在一些项目中，key 最好使用统一的命名模式，例如 user:123:passwd","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[],"parent":"a2661373f4d2"},{"id":"e9d71ed6c462","title":"4. Key&nbsp; 的名称需要注意区分大小写","style":{"border-radius":"20px","color":"rgb(242, 154, 102)","background-color":"rgb(255, 255, 255)","border-style":"solid","border-color":"rgb(242, 154, 102)","border-width":"2px"},"children":[],"parent":"a2661373f4d2"}],"parent":"005214a53d1c","icons":[{"text":"&#xe62b","index":"5","color":"rgb(255, 159, 26)","name":"priority"}],"collapsed":false}],"icons":[{"text":"&#xe625","index":"1","name":"priority"}],"collapsed":false},{"id":"92d048b3b8b4","title":"<font color=\"#381e11\">Redis 数据类型和<br>Java 操作 Redis</font><br>","parent":"root","children":[{"id":"55010f99735a","title":"String 类型","children":[{"id":"8c3421933657","title":"是什么 ？（简介）","children":[{"id":"35b0bd97ac7c","title":"string 是 redis 的最基本的类型， 一个 key 对应一个 value","children":[],"parent":"8c3421933657"},{"id":"cd531a470295","title":"string 类型是二进制安全的， 意思是 redis 的 string 可以包含任何数据， 比如 jpg 图拼啊或者序列化的对象","children":[],"parent":"8c3421933657"},{"id":"1ada745f68ad","title":"string 类型是 redis 最基本的数据类型，一个键最大能存储 512MB","children":[],"parent":"8c3421933657"},{"id":"8a233e895bbc","title":"二进制安全是指，在传输数据时，在传输二进制的信息安全，<br>也就是不被篡改、破译等，如果被攻击，能够即使检测出来<br>","children":[{"id":"f15d2f24de1b","title":"特点","parent":"8a233e895bbc","children":[{"id":"277441ad7191","title":"1. 编码、解码发生在客户端完成，执行效率高","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(255, 83, 92)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"f15d2f24de1b","children":[]},{"id":"0eb5257e6970","title":"2. 不需要平凡的编解码，不会出现乱码","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[],"parent":"f15d2f24de1b"}]}],"parent":"8c3421933657"}],"parent":"55010f99735a"},{"id":"4474b593f4d8","title":"怎么用？（常用命令）","children":[{"id":"4e40614c87b1","title":"赋值语法","children":[{"id":"4e18241f5020","title":"SET KEY_NAME VALUE","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(80, 194, 139)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[{"id":"5d51849035e3","title":"Redis SET 民力用于设定 key 值。 如果 key 已经存储值，SET 就覆盖旧值， 且无视类型","children":[],"parent":"4e18241f5020"}],"parent":"4e40614c87b1"},{"id":"c02888fc2c54","title":"SETNX&nbsp; KEY VALUE","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"4e40614c87b1","children":[{"id":"11162ed8e579","title":"只有 key 不存在设置 key 的值， setnx (SET is Not eXists) 命令在执行 key 不存在的时候，为 key 设置指定的值","parent":"c02888fc2c54","children":[]},{"id":"f32f08793f47","title":"具有原子性，可以解决分布式锁的问题","children":[],"parent":"c02888fc2c54"}]},{"id":"e8412a15e7bd","title":"MSET KEY&nbsp; VALUE[key vlue ...]","children":[{"id":"361a669035db","title":"同时设置一个或者多个 key-value 对","parent":"e8412a15e7bd","children":[]}],"parent":"4e40614c87b1"}],"parent":"4474b593f4d8"},{"id":"d54739469448","title":"取值语法","parent":"4474b593f4d8","children":[{"id":"f5c865424207","title":"GET KEY_NAME","parent":"d54739469448","children":[{"id":"8be517a1ede4","title":"Redis GET 命令用于获取指定 key 的值，如果不存在，返回 nil ， 如果 key 存储的值不是一字符串类型，返回一个错误","children":[],"parent":"f5c865424207"}]},{"id":"3b0cb3198f0b","title":"GETRANCE key start end","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(80, 194, 139)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[{"id":"1c8c3ebaa52a","title":"用于获取存储在指定key 中字符串的子字符串。<br>字符串的截取范围由 start 和 end 两个偏移量决定 （包括 start 和 end 在内的）<br>","parent":"3b0cb3198f0b","children":[]}],"parent":"d54739469448"},{"id":"54ac553ce96a","title":"GETBIT key offset","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(80, 194, 139)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"d54739469448","children":[{"id":"8714ba5cd7c4","title":"获取 key 所存储的字符串值， 获取指定偏移量上的位 bit","children":[],"parent":"54ac553ce96a"}]},{"id":"75f9232fa94b","title":"MCET&nbsp; key1 [key2 ..]","children":[{"id":"4ee9422b8575","title":"获取所有 （一个或多个）指定的值","parent":"75f9232fa94b","children":[]}],"parent":"d54739469448"},{"id":"5d30483ded87","title":"GETSET 语法： GETSET KEY_NAME VALUE","parent":"d54739469448","children":[{"id":"be9fede82bab","title":"GETSET 命令用于执行 key 值， 并放回 key&nbsp; 的旧值，当&nbsp; key 不存在时， 返回 nil","children":[],"parent":"5d30483ded87"}]},{"id":"86d2a9c859ec","title":"STRLEN key","children":[{"id":"ba729a6feadf","title":"返回 key 所存储的字符串的长度","children":[],"parent":"86d2a9c859ec"}],"parent":"d54739469448"}]},{"id":"b43ecda0170a","title":"删除语法","children":[{"id":"59ce670c5b05","title":"DEL KEY_NAME","children":[{"id":"b3759dba5f00","title":"删除指定的 key , 如果存在，返回数值类型。","children":[],"parent":"59ce670c5b05"}],"parent":"b43ecda0170a"}],"parent":"4474b593f4d8"},{"id":"897c0f21fb2c","title":"自增/自减","parent":"4474b593f4d8","children":[{"id":"d430f858f852","title":"INCR KEY_NAME","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"897c0f21fb2c","children":[{"id":"a501c53a24b1","title":"INCR 命令将 key 中存储的数值增 1 ， 如果 key 的值会掀背初始化为0 ，然后再执行 INCR 操作","children":[],"parent":"d430f858f852"}]},{"id":"e8ed3312cc33","title":"自增：INCRBY KEY_NAME 增量值","parent":"897c0f21fb2c","children":[{"id":"bfb37450b1cf","title":"INCRBY 命令将 key 中存储的数字加上指定的增量值","parent":"e8ed3312cc33","children":[]}]},{"id":"10e896b56067","title":"自减：DECR KEY_VALUE 或 DECYBY KEY_VALUE 减值","children":[{"id":"323fd4c5f7ff","title":"DECR 命令将 key 存的数字减 1&nbsp;","children":[],"parent":"10e896b56067"}],"parent":"897c0f21fb2c"},{"id":"ebd40034d3f8","title":"字符串拼接： APPEND KEY_NAME VALUE","parent":"897c0f21fb2c","children":[{"id":"36ed3968dbc6","title":"APPEND 命令用于为指定的 key 追加至末尾，如果不存在为其赋值","parent":"ebd40034d3f8","children":[]}]}]}],"parent":"55010f99735a"},{"id":"a014d9fbf05c","title":"应用场景","children":[{"id":"de74f012c784","title":"<font color=\"#c41230\">1. String 通常用于保存单个字符串或 JSON 字符串数据</font>","children":[],"parent":"a014d9fbf05c"},{"id":"3c6383ee430d","title":"<font color=\"#c41230\">2. 因 String 是二进制安全的</font>，所以完全可以把一个图片的内容作为字符串来存储","parent":"a014d9fbf05c","children":[]},{"id":"1528f8699911","title":"<font color=\"#c41230\">3. 计数器</font>（常规 key-value 缓存运用， 常规计数：微博数，粉丝数）","children":[],"parent":"a014d9fbf05c"},{"id":"f7a4af6838b8","title":"<font color=\"#c41230\">INCR 等指令本来就具有原子性特征</font>，所以我们完全可以利用 redis 的<br> INCR ， INCRBY，DECR， DECRBY 等命令来实现原子计数的效果。<br>假如，在某种场景下有 3 个客户同时读取了&nbsp; mynum 的值（值为2），然后对其进行加1的操作，<br> 那么， 最后mynum 的值一定是 5 。不少网站都用了redis 这个特征来实现业务上的统计需求<br>","parent":"a014d9fbf05c","children":[]}],"parent":"55010f99735a"}],"parent":"92d048b3b8b4","collapsed":false},{"id":"4c24b0770b05","title":"Hash 类型","parent":"92d048b3b8b4","children":[{"id":"8ac24e1ec5d4","title":"简介","children":[{"id":"d5a7d05e57b3","title":"Redis hash 是一个 string 类型的 field 和 value 的映射表， hash 特别适合用于<font color=\"#c41230\">存储对象<br></font>Redis 中每个 hash 可以存储 2^32 -1 键值对（40多亿）可以看成是具有 key 和 value 的 MAP 容器，<br>该类型非常适合于存储对象的信息如：uname, upass, age 等， 该类型的数据仅占很少的磁盘空间 （相对于JSON）","children":[],"parent":"8ac24e1ec5d4"}],"parent":"4c24b0770b05","collapsed":false},{"id":"8030bc7d79c3","title":"常用命令","children":[{"id":"e025e9e87a41","title":"赋值语法","parent":"8030bc7d79c3","children":[{"id":"a2a38482cc10","title":"HSET&nbsp; KEY FIELD VALUE","parent":"e025e9e87a41","children":[{"id":"58e0459e0507","title":"为指定KEY 设定 FIELD/VALUE","parent":"a2a38482cc10","children":[]}]},{"id":"f327ac6ead53","title":"HMET KEY FIELD VLUE [FILELD1 , VLAUE1]","parent":"e025e9e87a41","children":[]},{"id":"a3899840975c","title":"举例： hmset users:1 id 1 uname zhangsan age 22","parent":"e025e9e87a41","children":[]}],"collapsed":false},{"id":"1bd98c6ebb2b","title":"取值语法","parent":"8030bc7d79c3","children":[{"id":"6b11dd782281","title":"HGET KEY VALUE","parent":"1bd98c6ebb2b","children":[{"id":"805919be9d3a","title":"获取存储在 HASH 中的值，根据 FIELD 得到 VLAUE","parent":"6b11dd782281","children":[]}]},{"id":"5b404aa74db1","title":"HMGET key field [field]","children":[{"id":"673f429c8310","title":"获取 KEY 所有给定字段的值","parent":"5b404aa74db1","children":[]}],"parent":"1bd98c6ebb2b"},{"id":"47a6915e03ea","title":"HGETALL key","parent":"1bd98c6ebb2b","children":[{"id":"c478e6a3d328","title":"返回 HASH&nbsp; 表中所有的字段和值","children":[],"parent":"47a6915e03ea"}]},{"id":"06d11f30b5d5","title":"HKEYS&nbsp; key","children":[{"id":"b474b526aa12","title":"获取所有哈希表中的字段","parent":"06d11f30b5d5","children":[]}],"parent":"1bd98c6ebb2b"},{"id":"b763a69cb62a","title":"HLEN key","parent":"1bd98c6ebb2b","children":[{"id":"0aff088b045e","title":"获取 hash 表中的字段数量","children":[],"parent":"b763a69cb62a"}]}],"collapsed":false},{"id":"52914a54080d","title":"删除语法","children":[{"id":"0e6d722fedfc","title":"HDEL KEY field1 [field2]","parent":"52914a54080d","children":[{"id":"2838764f9763","title":"删除一个或者多个 HASH 表字段","parent":"0e6d722fedfc","children":[]}]}],"parent":"8030bc7d79c3","collapsed":false},{"id":"d4a94d74279d","title":"其他语法","parent":"8030bc7d79c3","children":[{"id":"5f1896970a23","title":"HSETNX key field value&nbsp;","children":[{"id":"bc8e0c28786b","title":"只有在字段 field 不存在时， 设置哈希表的字段值","children":[],"parent":"5f1896970a23"}],"parent":"d4a94d74279d"},{"id":"1d30d9dd6e5a","title":"HINCRBY key field increment","parent":"d4a94d74279d","children":[{"id":"66a657a95afc","title":"为哈希表 key 中的指定字段的浮点数值加上增量 increment","parent":"1d30d9dd6e5a","children":[]}]},{"id":"d397948504f8","title":"HINCRBYFLOAT key field increment&nbsp;","children":[{"id":"acd556a0d45d","title":"为哈希表 key 中国呢的指定字段的浮点数值增加上增量 increment","children":[],"parent":"d397948504f8"}],"parent":"d4a94d74279d"},{"id":"aefe7fe43e3f","title":"HEXISTS&nbsp; key field&nbsp;","parent":"d4a94d74279d","children":[{"id":"fa99705f5132","title":"查看哈希表 key 中，指定字段是否存在","parent":"aefe7fe43e3f","children":[]}]}],"collapsed":false}],"parent":"4c24b0770b05","collapsed":false},{"id":"d396417b24f8","title":"使用场景","children":[{"id":"896bd4bb3c5a","title":"<font color=\"#c41230\">1. 适合存一个对象</font>，比如存储用户信息，订单信息等","children":[],"parent":"d396417b24f8"},{"id":"41f7845c6b02","title":"2. 为什么不用 string 存储一个对象？","style":{"border-radius":"20px","color":"rgb(242, 154, 102)","background-color":"rgb(255, 255, 255)","border-style":"solid","border-color":"rgb(242, 154, 102)","border-width":"2px"},"children":[{"id":"1647b6466947","title":"hash 是最捷径关系型数据结构的数据类型，可以将一个库一条记录或存续中一个对象转换为 hashmap 存放在 redis 中","children":[],"parent":"41f7845c6b02"},{"id":"045ebe5b661f","title":"用户 id 为查找的key , 存储的 value 用户对象包含：姓名，年龄，生日等信息，<br>如果用普通的 key/value 结构来存储，主要有2中方式。<br>","children":[{"id":"3a7c110200b0","title":"第一种方式将用户ID作为查找 KEY 把其他信息封装成一个对象以序列化的方式存储，<br>这种方式的缺点是，增加了序列化，反序列化的开销，并且在需要修改其中一项信息的时候，<br>需要把整个对象取出来，并且修改操作需要对并发进行保护，<font color=\"#c41230\">引入CAS等复杂</font>问题。","children":[],"parent":"045ebe5b661f"},{"id":"0d684cc4b95d","title":"第二种方式将这个用户对象有多少个成员就存成多少个 key-value 对，用户ID + 对应属性的名称作为<br>唯一标示来取得对应的属性值，虽然省取了序列化开销和并发问题，但是用户ID为重复存储， <br>如果存在大量这样的数据，内存浪费还是非常客观的。<br>","parent":"045ebe5b661f","children":[]}],"parent":"41f7845c6b02"}],"parent":"d396417b24f8","collapsed":false}],"parent":"4c24b0770b05"},{"id":"2eb3af26126e","title":"小总结","children":[{"id":"c8044df56be2","title":"Redis&nbsp; 提供的 HASH 很好的解决了这个问题， Redis 的 Hash 世纪是内部存储的 Value 为一个&nbsp; HashMap ， <br>并且提供了直接存取这个Map 的成员接口<br>","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(255, 83, 92)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"2eb3af26126e","children":[]},{"id":"9015ead554c0","title":"Redis 不会保留没有 Key 的 Hash&nbsp;","parent":"2eb3af26126e","children":[]}],"parent":"4c24b0770b05"}],"collapsed":false},{"id":"24f47e71cdc0","title":"Java 操作 Redis&nbsp;","children":[{"id":"2f24bfc77397","title":"Jedis 基本使用","children":[{"id":"9230d6e2ca85","title":"POM","children":[],"parent":"2f24bfc77397","note":"```xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;ssm-redis&lt;/artifactId&gt;\n        &lt;groupId&gt;org.example&lt;/groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;artifactId&gt;ssm-redis-jedis&lt;/artifactId&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n            &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n&lt;/project&gt;\n```"},{"id":"ac4ee77785dc","title":"测试类","children":[],"parent":"2f24bfc77397","note":"```java\npackage cn.edu.cqvie.jedis;\n\nimport org.junit.jupiter.api.Test;\nimport redis.clients.jedis.Jedis;\n\npublic class RedisDemo {\n\n    public static void main(String[] args) {\n        String host = &quot;127.0.0.1&quot;;\n        int port = 6379;\n        Jedis jedis = new Jedis(host, port);\n\n        // 判断 jedis 是否链接成功\n        System.out.println(jedis.ping());\n    }\n\n    /**\n     * Redis 测试字符串 string\n     * Redis 中有那些命令，Jedis 就有那些方法\n     */\n    @Test\n    public void t1() {\n        // 获取 Redis 的链接\n        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);\n\n        jedis.set(&quot;strName&quot;, &quot;字符串的名称&quot;);\n        String strName = jedis.get(&quot;strName&quot;);\n        System.out.println(&quot;redis 中的数据：&quot; + strName);\n        jedis.close();\n    }\n\n    /**\n     * Redis String 作用：为了减少数据（DB）的访问压力需求：\n     * 判断某个 key 是否存在，如果存在，就从 Redis 中查询\n     * 如果不存在，就查询数据库，且要将查询处的数据存入 Redis\n     */\n    @Test\n    public void t2() {\n        // 获得 Redis 链接\n        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);\n\n        // key 的名称\n        String key = &quot;applicationName&quot;;\n\n        if (jedis.exists(key)) {\n            String result = jedis.get(key);\n            System.out.println(&quot;Redis 数据中查询得到：&quot; + result);\n        } else {\n            // 在数据库中查询\n            String result = &quot;Jedis 测试小程序&quot;;\n            jedis.set(key, result);\n            System.out.println(&quot;DB 数据中查询得到：&quot; + result);\n        }\n\n        jedis.close();\n    }\n}\n\n```"}],"parent":"24f47e71cdc0"},{"id":"50f6c31bc239","title":"Jedis 工具类","children":[{"id":"8f786437c98d","title":"JedisPool","parent":"50f6c31bc239","children":[{"id":"1a4a7d1a5dd6","title":"获取Jedis 的工具类","parent":"8f786437c98d","children":[],"note":"```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class RedisPoolUtil {\n\n    private static JedisPool jedisPool;\n\n    static {\n        // 1 连接池 Redis POOL 基本信息\n        JedisPoolConfig c = new JedisPoolConfig();\n        // 最大连接数\n        c.setMaxTotal(8);\n        // 最大空闲数\n        c.setMaxIdle(2);\n\n        // 2 连接池\n        jedisPool = new JedisPool(c, &quot;127.0.0.1&quot;, 6379);\n    }\n\n    /**\n     * 获取 Jedis 链接\n     *\n     * @return\n     */\n    public static Jedis getJedis() {\n        return jedisPool.getResource();\n    }\n\n    /**\n     * 关闭 Jedis 链接\n     *\n     * @param jedis\n     */\n    public static void close(Jedis jedis) {\n        jedis.close();\n    }\n}\n\n```"},{"id":"a51520b3cc4f","title":"测试代码","children":[],"parent":"8f786437c98d","note":"```java\nimport org.junit.jupiter.api.Test;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class RedisDemo2 {\n\n    public static void main(String[] args) {\n        // 1 连接池 Redis POOL 基本信息\n        JedisPoolConfig c = new JedisPoolConfig();\n        // 最大连接数\n        c.setMaxTotal(8);\n        // 最大空闲数\n        c.setMaxIdle(2);\n\n        // 2 连接池\n        JedisPool jedisPool = new JedisPool(c, &quot;127.0.0.1&quot;, 6379);\n\n        Jedis jedis = jedisPool.getResource();\n        System.out.println(jedis.ping());\n    }\n\n\n    /**\n     * Redis String 作用：为了减少数据（DB）的访问压力需求：\n     * 判断某个 key 是否存在，如果存在，就从 Redis 中查询\n     * 如果不存在，就查询数据库，且要将查询处的数据存入 Redis\n     */\n    @Test\n    public void t2() {\n        // 获得 Redis 链接\n        Jedis jedis = RedisPoolUtil.getJedis();\n\n        // key 的名称\n        String key = &quot;applicationName&quot;;\n\n        if (jedis.exists(key)) {\n            String result = jedis.get(key);\n            System.out.println(&quot;Redis 数据中查询得到：&quot; + result);\n        } else {\n            // 在数据库中查询\n            String result = &quot;Jedis 测试小程序&quot;;\n            jedis.set(key, result);\n            System.out.println(&quot;DB 数据中查询得到：&quot; + result);\n        }\n\n        RedisPoolUtil.close(jedis);\n    }\n}\n\n```"}]}],"parent":"24f47e71cdc0"},{"id":"98964bbc44c2","title":"Jedis 对 Hash 类型的操作","children":[{"id":"7312d13e8377","title":"domain","parent":"98964bbc44c2","children":[],"note":"```java\npublic class User {\n\n    private Integer id;\n    private String name;\n    private Integer age;\n\n    public static String getKeyName() {\n        return &quot;user:&quot;;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return &quot;User{&quot; +\n                &quot;id=&quot; + id +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &#39;}&#39;;\n    }\n}\n```"},{"id":"04249711e1ca","title":"测试代码","children":[],"parent":"98964bbc44c2","note":"```java\npublic class RedisDemo3 {\n\n    /**\n     * Jedis 完成对 Hash 类型操作\n     * 需求：hash 存储一个对象\n     * 判断Redis 是否存在该 key ,  如果存在，直接返回值\n     * 如果不存在，查询数据库，（查询的结果 存入 redis） 并返回给用户\n     */\n    @Test\n    public void t1() {\n        // 获得 Redis 链接\n        Jedis jedis = RedisPoolUtil.getJedis();\n\n        // key 的名称\n        String key = &quot;users&quot;;\n\n        if (jedis.exists(key)) {\n            Map&lt;String, String&gt; map = jedis.hgetAll(key);\n\n            System.out.println(&quot;Redis 数据中查询得到：&quot; + map);\n        } else {\n            // 查询赋值\n            jedis.hset(key, &quot;id&quot;, &quot;1&quot;);\n            jedis.hset(key, &quot;name&quot;, &quot;宋江&quot;);\n            jedis.hset(key, &quot;age&quot;, &quot;22&quot;);\n            jedis.hset(key, &quot;remark&quot;, &quot;这个一个好汉&quot;);\n\n            System.out.println(&quot;DB 数据中查询得到：--- &quot;);\n        }\n\n        RedisPoolUtil.close(jedis);\n    }\n\n\n    @Test\n    public void t2() {\n\n        //Users selectById(String id);\n\n        // 获得 Redis 链接\n        Jedis jedis = RedisPoolUtil.getJedis();\n\n        String id = &quot;2&quot;;\n        // key 的名称\n        String key = User.getKeyName() + id;\n\n        if (jedis.exists(key)) {\n            Map&lt;String, String&gt; map = jedis.hgetAll(key);\n\n            User user = new User();\n            user.setId(Integer.parseInt(map.get(&quot;id&quot;)));\n            user.setName(map.get(&quot;name&quot;));\n            user.setAge(Integer.parseInt(map.get(&quot;age&quot;)));\n\n            System.out.println(&quot;Redis 数据中查询得到：&quot; + user);\n        } else {\n            // 查询赋值\n            User user = new User();\n            user.setId(Integer.parseInt(id));\n            user.setName(&quot;吴用&quot;);\n            user.setAge(22);\n\n            Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();\n            map.put(&quot;id&quot;, user.getId() + &quot;&quot;);\n            map.put(&quot;name&quot;, user.getName());\n            map.put(&quot;age&quot;, user.getAge() + &quot;&quot;);\n\n            jedis.hset(key, map);\n\n            System.out.println(&quot;DB 数据中查询得到：&quot; + user);\n        }\n\n        RedisPoolUtil.close(jedis);\n    }\n}\n\n```"}],"parent":"24f47e71cdc0"},{"id":"d20091d7e307","title":"Spring-Data 整合 Redis","parent":"24f47e71cdc0","children":[{"id":"1222e42ca6b2","title":"简介","parent":"d20091d7e307","children":[{"id":"bc8c12535bc1","title":"Spring data 提供了 RedisTemplate 模版它封装了 redis 连接池管理的逻辑，业务代码无需关心获取，释放链接逻辑；<br>spring redis 同时支持 Jedis，Jredis,&nbsp; rjc 客户端操作","children":[],"parent":"1222e42ca6b2"}]},{"id":"d5183ac2bdc6","title":"RedisTemplate 操作 string 使用案例","parent":"d20091d7e307","children":[{"id":"d8e318489f70","title":"POM","children":[],"parent":"d5183ac2bdc6","note":"```xml\n        &lt;dependency&gt;\n            &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n            &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;\n                    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n            &lt;/exclusions&gt;\n        &lt;/dependency&gt;\n```"},{"id":"637f6607aa47","title":"配置类","parent":"d5183ac2bdc6","children":[],"note":"```java\n@Import(UserServiceImpl.class)\n@Configuration\npublic class AppConfig {\n\n    @Bean\n    public JedisPoolConfig jedisPoolConfig() {\n        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\n        // 最大连接数\n        jedisPoolConfig.setMaxTotal(16);\n        // 最大空闲连接数\n        jedisPoolConfig.setMaxIdle(2);\n        return jedisPoolConfig;\n    }\n\n    @Bean\n    public JedisConnectionFactory jedisConnectionFactory(JedisPoolConfig jedisPoolConfig) {\n        RedisStandaloneConfiguration redisConfig = new RedisStandaloneConfiguration();\n        redisConfig.setHostName(&quot;127.0.0.1&quot;);\n        redisConfig.setPort(6379);\n        redisConfig.setDatabase(0);\n\n        JedisClientConfiguration.DefaultJedisClientConfigurationBuilder jpcb =\n                (JedisClientConfiguration.DefaultJedisClientConfigurationBuilder) JedisClientConfiguration.builder();\n        jpcb.poolConfig(jedisPoolConfig);\n        jpcb.usePooling();\n        JedisClientConfiguration jedisClientConfig = jpcb.build();\n\n        JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory(redisConfig, jedisClientConfig);\n        return jedisConnectionFactory;\n    }\n\n    @Bean\n    public RedisTemplate redisTemplate(JedisConnectionFactory jedisConnectionFactory) {\n        RedisTemplate redisTemplate = new RedisTemplate();\n        redisTemplate.setConnectionFactory(jedisConnectionFactory);\n        // 设置字符串序列化\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\n        redisTemplate.setValueSerializer(new StringRedisSerializer());\n        return redisTemplate;\n    }\n}\n\n```"},{"id":"51bfb6b3c598","title":"domain","parent":"d5183ac2bdc6","children":[],"note":"```java\npublic class User implements Serializable {\n\n    private Integer id;\n    private String name;\n    private Integer age;\n\n    public static String getKeyName() {\n        return &quot;user:&quot;;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return &quot;User{&quot; +\n                &quot;id=&quot; + id +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &#39;}&#39;;\n    }\n}\n```"},{"id":"b9d76e3a1423","title":"service","parent":"d5183ac2bdc6","children":[],"note":"* 接口类\n```java\npublic interface UserService {\n\n    public String getString(String key);\n}\n\n```\n\n* 实现类\n```java\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    private RedisTemplate&lt;String, String&gt; redisTemplate;\n\n    /**\n     * 通过某个key得到值\n     * 如果 key 在 redis 中不存在，到数据库进行查询\n     * 如果存在，就到 redis 中查询\n     *\n     * @param key\n     * @return\n     */\n    public String getString(String key) {\n        ValueOperations&lt;String, String&gt; vos = redisTemplate.opsForValue();\n        if (redisTemplate.hasKey(key)) {\n            System.out.println(&quot;在 Redis 取出并返回&quot;);\n            return vos.get(key);\n        } else {\n            // 查询数据库\n            String result = &quot;RedisTemplate 练习&quot;;\n            long timeout = 100;\n            // 设置 key 的值且设置过期时间为 100 秒\n            vos.set(key, result, timeout, TimeUnit.SECONDS);\n            System.out.println(&quot;在 DB 取出并返回&quot;);\n            return result;\n        }\n    }\n}\n```"},{"id":"fd19963273c1","title":"测试类","parent":"d5183ac2bdc6","children":[],"note":"```java\nclass UserServiceImplTest {\n\n    @Test\n    void getString() {\n        ApplicationContext applicationContext =\n                new AnnotationConfigApplicationContext(AppConfig.class);\n        UserService userService = applicationContext.getBean(UserService.class);\n        String string = userService.getString(&quot;order:1&quot;);\n        System.out.println(&quot;取出结果：&quot; + string);\n    }\n}\n```"}]}]},{"id":"495b5b3988d4","title":"string 案例限制登录功能","parent":"24f47e71cdc0","children":[{"id":"c4ee0598849b","title":"案例描述","children":[{"id":"9d89184eab44","title":"用户在2分钟内，仅输入错误密码 5 次如果，超过次数，<br>限制其登录1小时（要求每次登录失败，都要给出相应提示）<br>","children":[{"id":"0d595c2b9fa3","title":"逻辑分析","children":[],"parent":"9d89184eab44","note":"登录次数 user:loginCount:fail:用户名\n\n1  判断当前用户的登录是否被限制登录\n  1.1 如果没有被限制\n    （执行登录功能）\n      2 如果登录成功\n          2. 1登录成功 -&gt; （清除输入密码错误次数信息）\n          2.3 登录不成功\n            3 记录登录错误次数\n            （判断 redis 的登录次数key 是否存在）         \n             3.1 如果不存在\n                 是第一次登录失败次数为 1\n                 user:loginCount:fail:用户名  进行复制， 同时设置有效期 \n              3.2 如果存在\n                        查询登录失败次数的 key 结果\n                  如果 结果 &lt; 4\n                        user:loginCount:fail: + 1\n                 否则 \n                        限制登录KEY存在，同时设置限制登录时间\n\n  1.2 如果用户被限制\n   （作出相应的提示）"}],"parent":"c4ee0598849b"}],"parent":"495b5b3988d4"},{"id":"1613188950ca","title":"案例实现","children":[{"id":"a443aa4b5c31","title":"domain","parent":"1613188950ca","children":[],"note":"User 类\n```java\npublic class User implements Serializable {\n\n    private Integer id;\n    private String name;\n    private Integer age;\n    private String username;\n    private String password;\n\n    public static String getKeyName() {\n        return &quot;user:&quot;;\n    }\n\n    /**\n     * 锁定用户登录key user:loginTime:lock:用户名\n     *\n     * @return\n     */\n    public static String getLoginTimeLockKey(String username) {\n        return &quot;user:loginTime:lock:&quot; + username;\n    }\n\n    /**\n     * 锁定用户登录key user:loginTime:lock:用户名\n     *\n     * @return\n     */\n    public static String getLoginCountFailKey(String username) {\n        return &quot;user:loginCount:fail:&quot; + username;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n}\n```"},{"id":"56a95eaeacb0","title":"service","children":[],"parent":"1613188950ca","note":"* service 接口\n```java\npublic interface UserService {\n\n    public String getString(String key);\n\n    /**\n     * 用户名和密码登录\n     *\n     * @param username 用户名\n     * @param password 密码\n     * @return 用户信息\n     */\n    public User login(String username, String password);\n\n    /**\n     * 登录校验\n     *\n     * @param user\n     * @return 给用户详细信息提示\n     */\n    public boolean loginValidate(User user);\n}\n```\n\n* service 实现类\n```java\n/**\n * 限制登录次数key user:loginCount:fail:用户名\n * 锁定用户登录key user:loginTime:lock:用户名\n * &lt;p&gt;\n * 执行登录功能时：\n * &lt;p&gt;\n * 1  判断当前用户的登录是否被限制登录\n * 1.1 如果没有被限制\n * （执行登录功能）\n * 2 如果登录成功\n * 2. 1登录成功 -&gt; （清除输入密码错误次数信息）\n * 2.3 登录不成功\n * 3 记录登录错误次数\n * （判断 redis 的登录次数key 是否存在）\n * 3.1 如果不存在\n * 是第一次登录失败次数为 1\n * user:loginCount:fail:用户名  进行设置， 同时设置有效期\n * 3.2 如果存在\n * 查询登录失败次数的 key 结果\n * if (结果 &lt; 4) {\n * user:loginCount:fail: + 1\n * } else {\n * 限制登录KEY存在，同时设置限制登录时间\n * }\n * 1.2 如果用户被限制\n * （作出相应的提示）\n *\n * @author zhengsh\n * @date 2020-03-19\n */\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    private RedisTemplate&lt;String, String&gt; redisTemplate;\n\n    /**\n     * 通过某个key得到值\n     * 如果 key 在 redis 中不存在，到数据库进行查询\n     * 如果存在，就到 redis 中查询\n     *\n     * @param key\n     * @return\n     */\n    public String getString(String key) {\n        ValueOperations&lt;String, String&gt; vos = redisTemplate.opsForValue();\n        if (redisTemplate.hasKey(key)) {\n            System.out.println(&quot;在 Redis 取出并返回&quot;);\n            return vos.get(key);\n        } else {\n            // 查询数据库\n            String result = &quot;RedisTemplate 练习&quot;;\n            long timeout = 1000;\n            // 设置 key 的值且设置过期时间为 1000 秒\n            vos.set(key, result, timeout, TimeUnit.SECONDS);\n            System.out.println(&quot;在 DB 取出并返回&quot;);\n            return result;\n        }\n    }\n\n\n    /**\n     * @param username 用户名\n     * @param password 密码\n     * @return\n     */\n    @Override\n    public User login(String username, String password) {\n        try {\n            // 1. 判断用户是否被限制登录\n            if (isNotLoginUserLock(username)) {\n                // 2. 执行登录教研\n                User user = new User();\n                user.setUsername(username);\n                if (loginValidate(user)) {\n                    // 登录成功\n                    setLoginCountFailExpire(username);\n                    System.out.println(&quot;====&gt; 登录成功&quot;);\n                    return user;\n                } else {\n                    // 3. 登录失败, 记录登录失败次数\n                    accLoginCountFail(username);\n                }\n            }\n            return null;\n        } catch (Throwable t) {\n            //t.printStackTrace();\n            System.err.println(&quot;====&gt; 登录失败: &quot; + t.getMessage());\n            return null;\n        }\n    }\n\n    /**\n     * @param user\n     * @return\n     */\n    @Override\n    public boolean loginValidate(User user) {\n        if (&quot;admin&quot;.equals(user.getPassword())) {\n            return true;\n        }\n        return false;\n    }\n\n\n    /**\n     * 判断登录用户是否被限制登录\n     * 查询当前key是否存在，如果存在就被限制。 注意，需要给用户做提示：您当前的用户登录已被限制还剩多少时间\n     *\n     * @param username\n     * @return\n     */\n    public boolean isNotLoginUserLock(String username) {\n        String loginTimeLockKey = User.getLoginTimeLockKey(username);\n        if (redisTemplate.hasKey(loginTimeLockKey)) {\n            Long expire = redisTemplate.getExpire(loginTimeLockKey, TimeUnit.MINUTES);\n            throw new RuntimeException(&quot;登录失败，您当前由于已被禁止登录，限制时间还剩：&quot; + expire + &quot;分钟&quot;);\n        }\n        return true;\n    }\n\n    /**\n     * 登录失败次数累加\n     *\n     * @param username\n     */\n    private synchronized void accLoginCountFail(String username) {\n        String k = User.getLoginCountFailKey(username);\n        int num = 5;\n        if (!redisTemplate.hasKey(k)) {\n            // 如果不存在\n            redisTemplate.opsForValue().set(k, &quot;1&quot;, 2, TimeUnit.MINUTES);\n            throw new RuntimeException(&quot;登录失败，在2分钟内还允许登录输入次数: &quot; + (num - 1));\n        } else {\n            int count = Integer.parseInt(Objects.requireNonNull(redisTemplate.opsForValue().get(k)));\n            // 如果小于4\n            if (count &lt; (num - 1)) {\n                // 累加\n                redisTemplate.opsForValue().increment(k, 1);\n                Long expire = redisTemplate.getExpire(k, TimeUnit.SECONDS);\n                throw new RuntimeException(&quot;登录失败，在&quot; + expire + &quot;秒内还允许登录输入次数: &quot; + (num - count - 1));\n            } else {\n                redisTemplate.opsForValue().set(User.getLoginTimeLockKey(username), &quot;1&quot;, 1, TimeUnit.HOURS);\n                throw new RuntimeException(&quot;因登录次数超过限制&quot; + num + &quot;次，对其限制登录1小时&quot;);\n            }\n        }\n    }\n\n    /**\n     * 设置计数的Key 立即失效\n     *\n     * @param username\n     */\n    private void setLoginCountFailExpire(String username) {\n        String k = User.getLoginCountFailKey(username);\n        if (redisTemplate.hasKey(k)) {\n            redisTemplate.expire(k, 0, TimeUnit.HOURS);\n        }\n    }\n\n\n}\n\n```"},{"id":"f7a5f95ff96a","title":"单元测试","parent":"1613188950ca","children":[],"note":"* 登录次数\n```java\n    @Test\n    void login() {\n        ApplicationContext applicationContext =\n                new AnnotationConfigApplicationContext(AppConfig.class);\n        UserService userService = applicationContext.getBean(UserService.class);\n        userService.login(&quot;admin1&quot;, &quot;admin&quot;);\n        userService.login(&quot;admin1&quot;, &quot;admin&quot;);\n        userService.login(&quot;admin1&quot;, &quot;admin&quot;);\n        userService.login(&quot;admin1&quot;, &quot;admin&quot;);\n        userService.login(&quot;admin1&quot;, &quot;admin&quot;);\n    }\n```"}],"parent":"495b5b3988d4"}]},{"id":"18e42b26c40d","title":"hash 类型案例","children":[{"id":"fcef5ad83df6","title":"POM","children":[],"parent":"18e42b26c40d","note":"```xml\n&lt;dependency&gt;\n            &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n            &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;\n                    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n            &lt;/exclusions&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n```"},{"id":"3a85ae7b3cd8","title":"配置类文件","children":[],"parent":"18e42b26c40d","note":"```java\n@Import(UserServiceImpl.class)\n@Configuration\npublic class AppConfig {\n\n    @Bean\n    public JedisPoolConfig jedisPoolConfig() {\n        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\n        // 最大连接数\n        jedisPoolConfig.setMaxTotal(16);\n        // 最大空闲连接数\n        jedisPoolConfig.setMaxIdle(2);\n        return jedisPoolConfig;\n    }\n\n    @Bean\n    public JedisConnectionFactory jedisConnectionFactory(JedisPoolConfig jedisPoolConfig) {\n        RedisStandaloneConfiguration redisConfig = new RedisStandaloneConfiguration();\n        redisConfig.setHostName(&quot;127.0.0.1&quot;);\n        redisConfig.setPort(6379);\n        redisConfig.setDatabase(0);\n\n        JedisClientConfiguration.DefaultJedisClientConfigurationBuilder jpcb =\n                (JedisClientConfiguration.DefaultJedisClientConfigurationBuilder) JedisClientConfiguration.builder();\n        jpcb.poolConfig(jedisPoolConfig);\n        jpcb.usePooling();\n        JedisClientConfiguration jedisClientConfig = jpcb.build();\n\n        JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory(redisConfig, jedisClientConfig);\n        return jedisConnectionFactory;\n    }\n\n    @Bean\n    public RedisTemplate redisTemplate(JedisConnectionFactory jedisConnectionFactory) {\n        RedisTemplate redisTemplate = new RedisTemplate();\n        redisTemplate.setConnectionFactory(jedisConnectionFactory);\n\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\n        redisTemplate.setValueSerializer(new StringRedisSerializer());\n\n        redisTemplate.setHashKeySerializer(new StringRedisSerializer());\n\n        FastJsonRedisSerializer fastJsonRedisSerializer = getFastJsonRedisSerializer();\n\n        redisTemplate.setHashValueSerializer(fastJsonRedisSerializer);\n        return redisTemplate;\n    }\n\n    private FastJsonRedisSerializer getFastJsonRedisSerializer() {\n        FastJsonRedisSerializer fastJsonRedisSerializer = new FastJsonRedisSerializer(Object.class);\n        FastJsonConfig fastJsonConfig = new FastJsonConfig();\n        ParserConfig parserConfig = new ParserConfig();\n        parserConfig.setAutoTypeSupport(true);\n        fastJsonConfig.setParserConfig(parserConfig);\n        fastJsonRedisSerializer.setFastJsonConfig(fastJsonConfig);\n        return fastJsonRedisSerializer;\n    }\n}\n\n```"},{"id":"7d2cd4d3fd32","title":"service","parent":"18e42b26c40d","children":[],"note":"* service 接口\n```java\nUser findById(Integer id);\n```\n\n* service 接口实现\n```java\npublic User findById(Integer id) {\n        HashOperations operations = redisTemplate.opsForHash();\n        if (operations.hasKey(User.getHashKeyName(), String.valueOf(id))) {\n            // 如果存在\n            User user = (User) operations.get(User.getHashKeyName(), String.valueOf(id));\n            return user;\n        } else {\n            // mock select\n\n            User user = new User();\n            user.setId(id);\n            user.setAge(22);\n            user.setName(&quot;Mack&quot;);\n            user.setUsername(&quot;admin&quot;);\n            user.setPassword(&quot;123&quot;);\n            operations.put(User.getHashKeyName(), String.valueOf(id), user);\n            return user;\n        }\n    }\n```"},{"id":"2da514cf2d42","title":"单元测试","parent":"18e42b26c40d","children":[],"note":"```java\n    @Test\n    void findById() {\n        ApplicationContext applicationContext =\n                new AnnotationConfigApplicationContext(AppConfig.class);\n        UserService userService = applicationContext.getBean(UserService.class);\n        User user = userService.findById(20);\n        //cn.edu.cqvie.jedis.domain.User@1dfd5f51\n        //cn.edu.cqvie.jedis.domain.User@475b7792\n        System.out.println(user);\n    }\n```"}],"parent":"24f47e71cdc0"}],"parent":"92d048b3b8b4","note":"在官方万盏有很多 Java 客户端。 有：Jedis/ Redisson /Jredis/ JDBC-Redis 等，其中官方推荐使用 Jedis 和 Reddisson , 常用 Jedis , \n\n","collapsed":false},{"id":"0ab0967717b4","title":"List 类型","parent":"92d048b3b8b4","children":[{"id":"347d3a36ab47","title":"简介","parent":"0ab0967717b4","children":[{"id":"94a512c9256a","title":"<font color=\"#c41230\">Redis 列表是简单的字符串列表，安扎插入顺序排序，你可以添加一个元素<br></font><span style=\"color: rgb(196, 18, 48);\">到列表的头部（左边）或者尾部（右边）</span><font color=\"#381e11\">一个列表最多可以包含 2^32 - 1 个元素<br>（4294967295， 每个列表超过 40 亿个元素）</font><br>","children":[],"parent":"347d3a36ab47"},{"id":"21aabccdd1ef","title":"类似 Java 语言中的 LinkedList 类型","parent":"347d3a36ab47","children":[]}]},{"id":"03048b8a8e40","title":"命令","children":[{"id":"23db22adcf21","title":"赋值语法","parent":"03048b8a8e40","children":[{"id":"c783a1f43385","title":"LPUSH key value1 [value2]","parent":"23db22adcf21","children":[{"id":"eb377cb84537","title":"将一个或多个值插入到列表头部（从左侧添加）","parent":"c783a1f43385","children":[]}]},{"id":"1019e16b3aa2","title":"RPUSH key value1 [value2]","children":[{"id":"f84cbb76af2f","title":"在列表中添加一个或多个值（从右侧添加）","parent":"1019e16b3aa2","children":[]}],"parent":"23db22adcf21"},{"id":"035f39f16e68","title":"LPUSHX key value","parent":"23db22adcf21","children":[{"id":"0cc83fe656cd","title":"将一个值插入到已经存在的头部列表。如果类标不存在，操作无效","children":[],"parent":"035f39f16e68"}]},{"id":"7cde459a0c23","title":"RPUSH&nbsp; key value","parent":"23db22adcf21","children":[{"id":"304b1d563aa4","title":"一个值插入已存在的列表尾部（最右边）。如果列表不存在，操作无效。","children":[],"parent":"7cde459a0c23"}]}]},{"id":"d98723bdbf47","title":"取值语法","children":[{"id":"0ff71579a8c0","title":"LLEN key","children":[{"id":"856f476fe28b","title":"获取列表长度","children":[],"parent":"0ff71579a8c0"}],"parent":"d98723bdbf47"},{"id":"f6c2713c418f","title":"LINDEX key index","parent":"d98723bdbf47","children":[{"id":"a6a93d78aedb","title":"通过索引获取列表中的元素","parent":"f6c2713c418f","children":[]}]},{"id":"3c408bfc4a04","title":"LRANDGE key start stop","children":[{"id":"e40937aa9b00","title":"获取列表指定范围内的元素","children":[],"parent":"3c408bfc4a04"}],"parent":"d98723bdbf47","note":"描述：返回列表中指定区间内元素，区间已偏移量 START 和 END 确定。其中 0 表示列表额度第一个元素, 1 表示列表的第一个元素，以此类推。也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒是第二个元素以此类推。"}],"parent":"03048b8a8e40"},{"id":"ba37c2797f02","title":"删除语法","parent":"03048b8a8e40","children":[{"id":"b44fcded3c6b","title":"LPOP key","children":[{"id":"4755972b49cd","title":"移除并获取列表的第一个元素（从左侧删除）","parent":"b44fcded3c6b","children":[]}],"parent":"ba37c2797f02"},{"id":"b8580aaeed82","title":"RPOP key","parent":"ba37c2797f02","children":[{"id":"b83ef6a02f6b","title":"移除列表的最后一个元素， 返回值为异常的元素（从右侧删除）","parent":"b8580aaeed82","children":[]}]},{"id":"a1ecbeced0f4","title":"BLPOP key1 [key2] timeout","parent":"ba37c2797f02","children":[{"id":"350257d72019","title":"移除并获取列表的第一个元素，如果列表没有是元素会足赛知道等待超时或发现可以弹出的元素为止。","parent":"a1ecbeced0f4","children":[]}],"note":"在上述实例中，操作会被阻塞， 如果指定的列表 key list1 存在数据则会返回第一个元素， 否则在等待 100 秒后返回 nil"},{"id":"4d3e42ce198f","title":"BRPOP key1 [key2] timeout","parent":"ba37c2797f02","children":[{"id":"44ef921134e0","title":"移除并获取列表的最后一个元素， 如果列表没有元素会阻塞列表知道等待超时或发现可弹出元素为止。","parent":"4d3e42ce198f","children":[]}]},{"id":"c4797aa9861f","title":"LTRIM key start stop","parent":"ba37c2797f02","children":[{"id":"acaac91f4b30","title":"对一个列表进行修剪（trim）, 就是说，让列表止保留指定区间内的元素， 不在指定区间内的元素都被删除。","parent":"c4797aa9861f","children":[]}]}]},{"id":"90fb79874668","title":"修改语法","children":[{"id":"f536c501f6fc","title":"LSET key index value&nbsp;","children":[{"id":"09d4a0a03af6","title":"通过索引设置列表元素的值","children":[],"parent":"f536c501f6fc"}],"parent":"90fb79874668"},{"id":"73b7054bf547","title":"LINSERT key BEFORE | AFTER&nbsp; world value","parent":"90fb79874668","children":[{"id":"e58deeec971c","title":"在类标的元素钱或后插入元素","parent":"73b7054bf547","children":[]}],"note":"描述：将值 value 插入到列表 key  中，位于值 world 之前或之后。\n"}],"parent":"03048b8a8e40"},{"id":"1405359d8ad4","title":"高级语法","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[{"id":"302a30f104c6","title":"RPOPLPUSH source destination","children":[{"id":"b34e1dbde33e","title":"移除列表的最后一个元素， 并将该元素添加到另一个列表并返回","children":[],"parent":"302a30f104c6"},{"id":"861b53149a73","title":"RPOPLPUSH a1 a2","parent":"302a30f104c6","children":[{"id":"6193861d5583","title":"a1 的最后元素移到 a2 的左侧","parent":"861b53149a73","children":[]}]},{"id":"abdb2f39f189","title":"RPOPLPUSH a1 a1","children":[{"id":"f3bd12081715","title":"循环列表，将最后元素移动到最右侧","children":[],"parent":"abdb2f39f189"}],"parent":"302a30f104c6"}],"parent":"1405359d8ad4"},{"id":"bbe374c89159","title":"BRPOPLPUSH source destination timeout","parent":"1405359d8ad4","children":[{"id":"6435d029986c","title":"从列表中弹出一的元素插入到另外一个类标中并放回它；<br>如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止<br>","parent":"bbe374c89159","children":[]}]}],"parent":"03048b8a8e40"}],"parent":"0ab0967717b4"},{"id":"92e52d636484","title":"应用场景","parent":"0ab0967717b4","children":[{"id":"833041879bdf","title":"项目常应用于：1. 对数据量大的集合数据删减 2、任务队列","parent":"92e52d636484","children":[]},{"id":"4065b5d47668","title":"1 对数据量数集合数据删减","children":[{"id":"77b3a3da96cf","title":"列表数据显示、关注列表、粉丝列表、留言评价等。。分页、热点新闻（top5）等","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[],"parent":"4065b5d47668"},{"id":"2e6ee32ddf18","title":"利用LRANGE 还可以很方便的实现分页功能， 在博客系统中，<br>每篇博文的评论也可以存入一个单独的list 中<br>","parent":"4065b5d47668","children":[]},{"id":"84ea7a2a8eba","title":"List 运用案例","style":{"border-radius":"20px","color":"rgb(242, 154, 102)","border-style":"solid","background-color":"rgb(255, 255, 255)","border-color":"rgb(242, 154, 102)","border-width":"2px"},"parent":"4065b5d47668","children":[{"id":"5db7efe2f728","title":"接口方法","children":[],"parent":"84ea7a2a8eba","note":"```java\n    public void listAdd();\n\n    public List&lt;String&gt; listRange();\n\n    public List&lt;String&gt; listPage(int pageNum, int pageSize);\n```"},{"id":"e636c32d628b","title":"实现方法","parent":"84ea7a2a8eba","children":[],"note":"```java\n@Override\n    public void listAdd() {\n        ListOperations&lt;String, String&gt; listOperations = redisTemplate.opsForList();\n        listOperations.leftPush(&quot;news:top10&quot;, &quot;首个电商平台项目上招标成功 美男可以为国家节约 20 亿&quot;);\n        listOperations.leftPush(&quot;news:top10&quot;, &quot;罗永浩带货靠谱吗？不一定是下一个李佳琦 但是也会让你意想不到&quot;);\n        listOperations.leftPush(&quot;news:top10&quot;, &quot;专访终极格斗世界冠军张伟丽：“我对胜利一直有百分之百的渴望”&quot;);\n        listOperations.leftPushAll(&quot;news:top10&quot;, &quot;java&quot;, &quot;redis&quot;);\n    }\n\n    @Override\n    public List&lt;String&gt; listRange() {\n        String key = &quot;news:top10&quot;;\n        ListOperations&lt;String, String&gt; listOperations = redisTemplate.opsForList();\n        return listOperations.range(key, 0, -1);\n    }\n\n    @Override\n    public List&lt;String&gt; listPage(int pageNum, int pageSize) {\n        String key = &quot;news:top10&quot;;\n        ListOperations&lt;String, String&gt; listOperations = redisTemplate.opsForList();\n        Long size = listOperations.size(key);\n        System.out.println(&quot;总记录数： &quot; + size);\n        // start: (pageNum - 1) * pageSize\n        // stop:  pageSize * pageNum -1\n        return listOperations.range(key, (pageNum - 1) * pageSize, (pageNum * pageSize - 1));\n    }\n```"},{"id":"f90a8b024995","title":"单元测试","children":[],"parent":"84ea7a2a8eba","note":"```java\n@Test\n    void listAdd() {\n        ApplicationContext applicationContext =\n                new AnnotationConfigApplicationContext(AppConfig.class);\n        UserService userService = applicationContext.getBean(UserService.class);\n        userService.listAdd();\n    }\n\n    @Test\n    void listRange() {\n\n        ApplicationContext applicationContext =\n                new AnnotationConfigApplicationContext(AppConfig.class);\n        UserService userService = applicationContext.getBean(UserService.class);\n        userService.listRange().forEach(System.out::println);\n    }\n\n    @Test\n    void listPage() {\n\n        ApplicationContext applicationContext =\n                new AnnotationConfigApplicationContext(AppConfig.class);\n        UserService userService = applicationContext.getBean(UserService.class);\n        userService.listPage(5, 3).forEach(System.out::println);\n    }\n```"}]}],"parent":"92e52d636484"},{"id":"c7225f15b303","title":"2. 任务队列","parent":"92e52d636484","children":[{"id":"fe86aaf9bead","title":"List 通常用来实现一个消息队列， 而且可以确保先后顺序，不必像 MySQL 那样还需要通过 ORDER BY 来进行排序","children":[],"parent":"c7225f15b303"},{"id":"cb097969ec87","title":"任务队列介绍（生产者和消费者模式）","parent":"c7225f15b303","children":[{"id":"2921dab77287","title":"在处理 Web 客户端发送的命令请求时，某些操作的执行时间可能会比我们预期的更长一些<br>通过将待执行任务的相关信息放入队列里面，并在之后对队列进行处理，用户可以通过推迟执行那些需要一段时间<br>才能完成的操作，这种将工作交给任务处理器来执行的做法成为任务队列 （ task queue）","parent":"cb097969ec87","children":[]}]},{"id":"5bbfe2df467c","title":"RPOPLPUSH source destination","parent":"c7225f15b303","children":[{"id":"e085bcf08eb4","title":"移除列表的最后一个元素， 并将该元素添加到另一个列表中返回","parent":"5bbfe2df467c","children":[]}]},{"id":"661dd96cee61","title":"常用案例","parent":"c7225f15b303","children":[{"id":"7b75cc892a25","title":"订单系统的下单流程、用户系统登录注册短信等","parent":"661dd96cee61","children":[]},{"id":"7379b696e0ea","title":"订单系统的下单流程","style":{"border-radius":"20px","color":"rgb(242, 154, 102)","background-color":"rgb(255, 255, 255)","border-style":"solid","border-color":"rgb(242, 154, 102)","border-width":"2px"},"parent":"661dd96cee61","children":[{"id":"65b9c712f9dd","title":"接口方法","children":[],"parent":"7379b696e0ea","note":"```java\npublic interface OrderService {\n\n    public void listQueueInit(String orderId);\n\n    public void listQueueTouch(String orderId);\n\n    public List&lt;String&gt; listQueueSucc(String orderId);\n\n    public List&lt;String&gt; listQueueWait(String orderId);\n}\n\n```"},{"id":"c637472bef55","title":"实现方法","parent":"7379b696e0ea","children":[],"note":"```java\n@Service\npublic class OrderServiceImpl implements OrderService {\n\n    @Autowired\n    private RedisTemplate&lt;String, String&gt; redisTemplate;\n\n    @Override\n    public void listQueueInit(String orderId) {\n        // 初始化 key 代表还是有多少未完成的操作\n        String key = &quot;order:&quot; + orderId + &quot;:init&quot;;\n//        商家发货\n//        小哥发件\n//        北京海淀区 AA 楼 --&gt; 首都机场\n//        首都机场 --&gt; 南京机场\n//        机场 --&gt; 建业区\n//        建业区 --&gt; 送到本人\n        redisTemplate.opsForList().leftPushAll(key,\n                &quot;1.商家发货&quot;,\n                &quot;2.小哥发件&quot;,\n                &quot;3.北京海淀区 AA 楼 --&gt; 首都机场&quot;,\n                &quot;4.首都机场 --&gt; 南京机场&quot;,\n                &quot;5.机场 --&gt; 建业区&quot;,\n                &quot;6.建业区 --&gt; 送到本人&quot;\n        );\n    }\n\n    /**\n     * 触发事件\n     *\n     * @param orderId\n     */\n    @Override\n    public void listQueueTouch(String orderId) {\n        // 已完成任务队列\n        String skey = &quot;order:&quot; + orderId + &quot;:init&quot;;\n        String dkey = &quot;order:&quot; + orderId + &quot;:succ&quot;;\n        redisTemplate.opsForList().rightPopAndLeftPush(skey, dkey);\n    }\n\n    @Override\n    public List&lt;String&gt; listQueueSucc(String orderId) {\n        String dkey = &quot;order:&quot; + orderId + &quot;:succ&quot;;\n        return  redisTemplate.opsForList().range(dkey, 0, -1);\n    }\n\n    @Override\n    public List&lt;String&gt; listQueueWait(String orderId) {\n        String skey = &quot;order:&quot; + orderId + &quot;:init&quot;;\n        return  redisTemplate.opsForList().range(skey, 0, -1);\n    }\n\n\n}\n```"},{"id":"3c49c218b53c","title":"单元测试","children":[],"parent":"7379b696e0ea","note":"```java\nclass OrderServiceImplTest {\n\n    private OrderService orderService;\n\n    @BeforeEach\n    public void init() {\n        ApplicationContext applicationContext =\n                new AnnotationConfigApplicationContext(AppConfig.class);\n        this.orderService = applicationContext.getBean(OrderService.class);\n    }\n\n\n    @Order(1)\n    @Test\n    void listQueueInit() {\n        //orderService.listQueueInit(&quot;1001&quot;);\n    }\n\n    @Order(20)\n    @Test\n    void listQueueWait() {\n        System.out.println(&quot;当前待执行队列：------- &gt;&quot;);\n        orderService.listQueueWait(&quot;1001&quot;).forEach(System.out::println);\n\n    }\n\n    @Order(30)\n    @Test\n    void listQueueTouch() {\n        orderService.listQueueTouch(&quot;1001&quot;);\n    }\n\n    @Order(40)\n    @Test\n    void listQueueSucc() {\n        System.out.println(&quot;当前已执行队列：------- &gt;&quot;);\n        orderService.listQueueSucc(&quot;1001&quot;).forEach(System.out::println);\n    }\n\n\n}\n```"}],"note":"* 订单系统的下单流程\n\n完成付款后：\n淘宝的后台帮我们生成一个队列 订单ID\n\n北京 --- 南京\n\n商家发货\n小哥发件\n北京海淀区 AA 楼 --&gt; 首都机场\n首都机场 --&gt; 南京机场\n机场 --&gt; 建业区\n建业区 --&gt; 送到本人\n\n商品评价\n"}]}]}]}],"collapsed":false},{"id":"eba65c762f16","title":"Set 类型","children":[{"id":"6135758dbf36","title":"简介","children":[{"id":"5d9acb634321","title":"Redis 的 Set 是 String 类型的无序集合， 集合成员是唯一的，这就以为这集合中不能出现重复的数据。","children":[],"parent":"6135758dbf36"},{"id":"74514e0d946e","title":"Redis 中集合通过哈希表来实现的， 所以添加，删除，查找的复杂度都是 O(1)","children":[],"parent":"6135758dbf36"},{"id":"0267a7bfb398","title":"Redis 集合中最大的成员数量是 2^(32-1) （4294967295，每个集合可以存储 40 多亿个成员）","children":[],"parent":"6135758dbf36"},{"id":"6d0a91494c12","title":"类似 Java 中的 HashTable 集合","parent":"6135758dbf36","children":[]},{"id":"bc05470af52d","title":"总结","parent":"6135758dbf36","children":[{"id":"09d7ba7725e2","title":"Redis 结合对象 set 底层存储结构特别神奇， 底层采用了 intset 和 hashtable 两种数据结构存储的， <br>instset 我们理解为数组， hashtable 就是普通的哈希表（key 为 set 的值， value 为 null）<br>","parent":"bc05470af52d","children":[]},{"id":"e7db4003d6f5","title":"inset 内部世纪是一个数组 (int8_t coentents[] 数组)，而且存储数据的时候是有序的，<br>因为在查找数据的时候是通过二分查找来实现的。<br>","parent":"bc05470af52d","children":[]}]}],"parent":"eba65c762f16"},{"id":"0bca2846788d","title":"命令","children":[{"id":"7c7a3fcebacf","title":"赋值语法","children":[{"id":"f0d1c42b6256","title":"SADD key member1 [member2]","children":[{"id":"25938bbdd595","title":"向集合添加一个或多个成员","children":[],"parent":"f0d1c42b6256"}],"parent":"7c7a3fcebacf"}],"parent":"0bca2846788d"},{"id":"60c476d4b0ef","title":"取值语法","parent":"0bca2846788d","children":[{"id":"4c7de643ca43","title":"SCARD key","style":{"font-weight":"bold"},"children":[{"id":"947345e3d051","title":"获取集合的成员数","children":[],"parent":"4c7de643ca43"}],"parent":"60c476d4b0ef"},{"id":"5629fddf28c7","title":"SMEMBERS&nbsp; key","style":{"font-weight":"bold"},"children":[{"id":"79e0b102c807","title":"返回集合汇总的所有成员","children":[],"parent":"5629fddf28c7"}],"parent":"60c476d4b0ef"},{"id":"114582963640","title":"SISMEMBER&nbsp; key&nbsp; member","style":{"font-weight":"bold"},"children":[{"id":"bc4a621b89c6","title":"判断 member 元素是否是集合 key 的成员（开发中：验证是否存在的判断）","children":[],"parent":"114582963640"}],"parent":"60c476d4b0ef"},{"id":"5688669297d0","title":"SRANDMEMBER key [count]","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px","font-weight":"bold"},"children":[{"id":"28d0b3a69d4e","title":"返回集合中一个或多个随机数","children":[],"parent":"5688669297d0"}],"parent":"60c476d4b0ef"}]},{"id":"8c8bbe396519","title":"删除语法","children":[{"id":"8e69dd5720ee","title":"SREM key member1 [member2]","style":{"font-weight":"bold"},"children":[{"id":"2e257d3092fc","title":"移除集合中一个或多个成员","children":[],"parent":"8e69dd5720ee"}],"parent":"8c8bbe396519"},{"id":"fa508eaae2b9","title":"SPOP key [count]","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px","font-weight":"bold"},"children":[{"id":"e3f2288a6f9a","title":"移除并返回集合中的一个随机元素","children":[],"parent":"fa508eaae2b9"}],"parent":"8c8bbe396519"},{"id":"8c642cb7d469","title":"SMOVE source destination member","style":{"border-radius":"0px","color":"rgb(102, 102, 102)","border-style":"dashed","background-color":"rgb(255, 255, 255)","border-color":"rgb(136, 136, 136)","font-weight":"bold","border-width":"1px"},"children":[{"id":"5cb0ebfdf231","title":"将 member 元素从 source 集合移动到 destination 集合","children":[],"parent":"8c642cb7d469"}],"parent":"8c8bbe396519"}],"parent":"0bca2846788d"},{"id":"44249495593f","title":"差集语法","children":[{"id":"4e11394172e0","title":"SDIFF key1 [key2]","style":{"font-weight":"bold"},"children":[{"id":"fdffd5251eed","title":"返回给所有集合的差集（左侧）","children":[],"parent":"4e11394172e0"}],"parent":"44249495593f"},{"id":"0f380d444d0f","title":"SDIFFSTORE destination key1 [key2]","style":{"font-weight":"bold"},"parent":"44249495593f","children":[{"id":"109bc0ba767e","title":"返回给定所有集合的差集并存储在 destination 中","parent":"0f380d444d0f","children":[]}]}],"parent":"0bca2846788d"},{"id":"6c6652bb77cc","title":"交集语法","children":[{"id":"b0e49a8b4201","title":"SINTER key1 [key2]","style":{"font-weight":"bold"},"children":[{"id":"cc35e1df157b","title":"返回给定所有结合的交集（共有数据）","children":[],"parent":"b0e49a8b4201"}],"parent":"6c6652bb77cc"},{"id":"343112581d00","title":"SINTERSTORE destination key1 [key2]","style":{"font-weight":"bold"},"parent":"6c6652bb77cc","children":[{"id":"2aab0628e913","title":"返回给定所有集合的交集并存储在 destination&nbsp; 中","parent":"343112581d00","children":[]}]}],"parent":"0bca2846788d"},{"id":"e12e664abb6f","title":"并集语法","children":[{"id":"34b730edd62a","title":"SUNION key1 [key2]&nbsp;","style":{"font-weight":"bold"},"children":[{"id":"222b820312c2","title":"返回所有给定集合的并集","children":[],"parent":"34b730edd62a"}],"parent":"e12e664abb6f"},{"id":"0cacab29786c","title":"SUNIONSTORE destincation key1 [key2]","style":{"font-weight":"bold"},"parent":"e12e664abb6f","children":[{"id":"b9e22c4956cc","title":"返回给定结集合的并集存储在 destination 集合中","parent":"0cacab29786c","children":[]}]}],"parent":"0bca2846788d"}],"parent":"eba65c762f16"},{"id":"cb7c2d96b604","title":"使用场景","children":[{"id":"5892391a2dcb","title":"常应用于：两个集合之间的数据 [计算] 进行交集、并集、差集运算","style":{"font-weight":"bold"},"children":[],"parent":"cb7c2d96b604"},{"id":"60f86fdfdcde","title":"1. 非常方便的实现如共同关注、共同喜好、二度好友等功能。对上面的所有集合数据操作，<br>你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。","parent":"cb7c2d96b604","children":[]},{"id":"6dac9adc1d68","title":"2. 利用唯一性，可以统计访问网站的所有独立 IP","children":[],"parent":"cb7c2d96b604"}],"parent":"eba65c762f16"}],"parent":"92d048b3b8b4","collapsed":false},{"id":"2a8adbe3f125","title":"ZSet （sorted set） 类型","children":[{"id":"a1e765f00288","title":"简介","children":[{"id":"d1f2797935a6","title":"1. Redis 有序集合和集合一样也是 string 类型的集合，且不允许重复的成员。","children":[],"parent":"a1e765f00288"},{"id":"2ef390ba30ff","title":"2. 不同的是每个元素都会关联一个double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。","parent":"a1e765f00288","children":[]},{"id":"2d0bfdba86d4","title":"3. 有序集合的成员是唯一的，但分数（score）却是可以重复。","children":[],"parent":"a1e765f00288"},{"id":"2eb4075d37c0","title":"4. 集合是通过哈希表实现的，所以添加，删除，查找的复杂度是O(1) . <br>集合中最大的成员数是 2^(32-1) (4294967295,&nbsp; 每个集合可以存储 40 多亿个成员)<br>","parent":"a1e765f00288","children":[]},{"id":"ec14359d9c86","title":"特点","parent":"a1e765f00288","children":[{"id":"28235cd02020","title":"Redis 的 ZSet 是有序的、且不重复","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(255, 83, 92)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"ec14359d9c86","children":[]},{"id":"fdb5943b095a","title":"很多时候，我们都将 redis 中的有序集合叫做 zsets , 这是因为 redis&nbsp; 中，有序集合相关的操作都是 z&nbsp; 开头的。","children":[],"parent":"ec14359d9c86"}]}],"parent":"2a8adbe3f125"},{"id":"28c7099b2d3a","title":"命令","children":[{"id":"3693f4c5c102","title":"赋值语法","parent":"28c7099b2d3a","children":[{"id":"19c79965d5ac","title":"zadd key score1 member1 [score2 member2]","parent":"3693f4c5c102","children":[{"id":"37a3f4833d58","title":"向有序集合添加一个或多个成员，或更新已存在成员的分数","children":[],"parent":"19c79965d5ac"}]}]},{"id":"88ff7d9653eb","title":"取值语法","children":[{"id":"6d741bdf331e","title":"ZCARD key","parent":"88ff7d9653eb","children":[{"id":"8c39d51f2fd9","title":"获取集合的成员个数","parent":"6d741bdf331e","children":[]}]},{"id":"56f94453ad63","title":"ZCOUNT key min max","children":[{"id":"c288336fb1cc","title":"计算在有序集合中指定成员的个数","parent":"56f94453ad63","children":[]}],"parent":"88ff7d9653eb"},{"id":"63ea8bc250d4","title":"ZRANK key member","parent":"88ff7d9653eb","children":[{"id":"92d739918ce5","title":"返回有序集合中指定的成员的索引","parent":"63ea8bc250d4","children":[]}]},{"id":"6c8a6489a966","title":"ZRANGE key start stop [WITHSCORES]","children":[{"id":"83855638fb6f","title":"通过索引区间返回有序集合成指定区间内的成员&nbsp;（低到高的排序）","parent":"6c8a6489a966","children":[]}],"parent":"88ff7d9653eb"},{"id":"1f5f65b40236","title":"ZREVRANGE key start stop&nbsp;[WITHSCORES]","parent":"88ff7d9653eb","children":[{"id":"3223499c88d0","title":"返回有序集中指定区间内的成员，通过索引， 分数从高到低","children":[],"parent":"1f5f65b40236"}]}],"parent":"28c7099b2d3a"},{"id":"1d9972cac71c","title":"删除语法","parent":"28c7099b2d3a","children":[{"id":"6a72aaded3cd","title":"del key&nbsp;","children":[{"id":"07c7b4fa94ea","title":"移除 key","children":[],"parent":"6a72aaded3cd"}],"parent":"1d9972cac71c"},{"id":"18585f879094","title":"ZREM key member [member .. ]","children":[{"id":"0e300f046a06","title":"移除集合中的一个或多个成员","children":[],"parent":"18585f879094"}],"parent":"1d9972cac71c"},{"id":"31c41b05853b","title":"ZREMRANGEBYRANK key start stop","children":[{"id":"75b5d26112b8","title":"&nbsp;移除有序集合中给定的<font color=\"#c41230\">排名区间</font>所有成员（第一名是0）（低到高的排序）","children":[],"parent":"31c41b05853b"}],"parent":"1d9972cac71c"},{"id":"b78c8a2f1ff4","title":"ZREMRANGEBYSCORE key min max","parent":"1d9972cac71c","children":[{"id":"9ae682cf4004","title":"移除有序集合汇总给定<font color=\"#c41230\">分数</font>区间的所有成员","children":[],"parent":"b78c8a2f1ff4"}]}]}],"parent":"2a8adbe3f125"},{"id":"b277e99b97b5","title":"使用场景","children":[{"id":"2cf518d0e21b","title":"常见运用： <font color=\"#c41230\">排行榜</font>","children":[],"parent":"b277e99b97b5"},{"id":"56475e5a166e","title":"1. 比如 twitter 的 public timeline 可以发表时间作为 score 来存储， 这样获取的时候就是自动按照时间排序的结果集","children":[],"parent":"b277e99b97b5"},{"id":"470daaf0e70d","title":"2. 比如一个存储全班同学的 sorted set, 其集合value 可以是同学的学好， 而 score 就可以是其考试得分，<br>这样在数据插入集合的时候，就已经进行了天然的排序。<br>","parent":"b277e99b97b5","children":[]},{"id":"c7ed78b382b7","title":"3. 还可以用 sorted set 来做待权重的队列，比如消息的 score 为 1, 重要的 score 为 2 ， <br>然后工作线程可以选择 按 score 来倒序获取工作任务。让重要的事情优先执行。<br>","children":[],"parent":"b277e99b97b5"}],"parent":"2a8adbe3f125"}],"parent":"92d048b3b8b4","collapsed":false}],"icons":[{"text":"&#xe62a","index":"2","color":"rgb(255, 159, 26)","name":"priority"}],"collapsed":false},{"id":"ba6919495c44","title":"Redis 其他功能","parent":"root","children":[{"id":"11326d19f103","title":"发布订阅","parent":"ba6919495c44","children":[{"id":"1198f6aedc57","title":"简介","parent":"11326d19f103","children":[{"id":"3744452b84c9","title":"Redis 发布订阅 （pub/sub）是一种消息通讯模式：发送者（pub）发送消息，<br>订阅者（sub）接收消息<br>","parent":"1198f6aedc57","children":[]},{"id":"aef5e8854540","title":"Redis 客户端可以订阅任意数量的频道","parent":"1198f6aedc57","children":[]}]},{"id":"5004801c7628","title":"示例","parent":"11326d19f103","children":[],"note":"下图展示了凭悼 channel1 , \n以及订阅这个频道的三个客户端 client2, client5  和  client2 之间的关系\n\n```mermaid\ngraph BT\nA(channel1)\n   C[client2] -- subscribe --&gt; A\n   D[client5] -- subscribe --&gt; A\n   E[client1] -- subscribe --&gt; A \n```\n\n当有新消息的时候通过 publish  发送命令给频道channel1 时， 这个消息就会被发送给它订阅的三个客户端。\n\n```mermaid\ngraph TB\nZ[PUBLISH channel1 message]\nZ --&gt; A(channel1)\n  A -- message --&gt; C[client2]\n  A -- message --&gt; D[client5]\n  A -- message --&gt; E[client1] \n```\n"},{"id":"017e47b05040","title":"命令","children":[{"id":"1ed6fe2e6ac0","title":"订阅频道","parent":"017e47b05040","children":[{"id":"daea87f7906a","title":"SUBSCRIBE channel [channel ...]","children":[{"id":"b6037a9c46be","title":"订阅给定的一个或多个凭悼的信息","children":[],"parent":"daea87f7906a"}],"parent":"1ed6fe2e6ac0"},{"id":"9ff764ff4d81","title":"PSUBSCRIBE pattern [pattern ...]","children":[{"id":"51c0a5ab5723","title":"订阅一个或多个富豪给定模式的频道","children":[],"parent":"9ff764ff4d81"}],"parent":"1ed6fe2e6ac0"}]},{"id":"85646fe8c9cb","title":"发布频道","children":[{"id":"d72ae156ef01","title":"PUBLISH channel message","children":[{"id":"f916946a5512","title":"将信息发布到指定的频道","parent":"d72ae156ef01","children":[]}],"parent":"85646fe8c9cb"}],"parent":"017e47b05040"},{"id":"37bdf2abcdbb","title":"退订频道","parent":"017e47b05040","children":[{"id":"53e2af4d6f85","title":"UNSUBSCRIBE [channel [chennel ... ]]","children":[{"id":"3312260d36f3","title":"退订给定的频道","children":[],"parent":"53e2af4d6f85"}],"parent":"37bdf2abcdbb"},{"id":"032fb1c73e8b","title":"PUNSUBSCRIBE [pattern [pattern ... ]]","parent":"37bdf2abcdbb","children":[{"id":"986ac6ccaa92","title":"退订素有给定模式频道","parent":"032fb1c73e8b","children":[]}]}]}],"parent":"11326d19f103"},{"id":"7cb21198032f","title":"运用场景","parent":"11326d19f103","children":[{"id":"19d620ec03b1","title":"这个一个功能最明显的用法即使构建实时的消息系统，比如普通的<font color=\"#c41230\">即时聊天，群聊</font>等功能","children":[],"parent":"7cb21198032f"},{"id":"226356600053","title":"<font color=\"#c41230\">1. 在一个博客网站中，有100个粉丝订阅了你，当你发布新文章，就可以推送消息给粉丝们</font>","children":[],"parent":"7cb21198032f"},{"id":"016bfc2005c6","title":"<span style=\"font-size: inherit;\"><font color=\"#c41230\">2. 微信公众号模式</font></span><br>","parent":"7cb21198032f","children":[]}],"collapsed":false}],"icons":[{"text":"&#xe67a","index":"0","color":"rgb(191, 30, 27)","name":"priority"}],"collapsed":false},{"id":"d6c37c88dc44","title":"多数据库","children":[{"id":"33cfba334ec4","title":"简介","parent":"d6c37c88dc44","children":[{"id":"dbd21b4b1ed4","title":"Redis 下， 数据库是由一个证书索引标示， 而不是由一个数据库名称，默认情况下，一个客户端链接到数据库 0","children":[],"parent":"33cfba334ec4"}]},{"id":"00b44739bc76","title":"命令","children":[{"id":"ccc3df746e7e","title":"select 数据库","children":[{"id":"f525500a9a7e","title":"数据库的切换","children":[],"parent":"ccc3df746e7e"}],"parent":"00b44739bc76"},{"id":"a00e49e2aee0","title":"move key 名称 数据库","children":[{"id":"b3c2c1aa5727","title":"移动数据（当前key 移动到另外一个数据库中）<br>","children":[],"parent":"a00e49e2aee0"}],"parent":"00b44739bc76"},{"id":"e688e690f516","title":"flushdb","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(80, 194, 139)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[{"id":"5c45d5053bb7","title":"清除当前数据库的所有 key","children":[],"parent":"e688e690f516"}],"parent":"00b44739bc76"},{"id":"24adc2d733fc","title":"flushall","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[{"id":"fb7efe489eeb","title":"清理整个 Redis 的数据库所有 key","children":[],"parent":"24adc2d733fc"}],"parent":"00b44739bc76"}],"parent":"d6c37c88dc44"},{"id":"cfd388739e50","title":"缓存预热","children":[],"parent":"d6c37c88dc44"}],"parent":"ba6919495c44","icons":[{"text":"&#xe625","index":"1","color":"rgb(99, 171, 247)","name":"priority"}],"collapsed":false},{"id":"fd794deca5dd","title":"Redis 事务","children":[{"id":"5f404152c122","title":"简介","children":[{"id":"7108ebeb6353","title":"Redis 时许可以一次执行多条命令（允许子啊一次单独的步骤中执行一组命令），<br>并且带有一下两个重要的保证","children":[{"id":"30d1fdfc7b72","title":"批量操作在发送 exec 命令之前被放入队列缓存。<br>收到 EXEC 命令 后进行入事务执行队列，事务中任意命令势必啊，其余的命令依然被执行。<br>在事务执行过程，其他的客户端提交的命令不会插入到事务执行命令序列中。","parent":"7108ebeb6353","children":[]},{"id":"255540c6d807","title":"<font color=\"#c41230\">1. Redis 会将一个事务中的所有命令序列化，然后按照顺序执行</font>","children":[],"parent":"7108ebeb6353"},{"id":"fa6cb3490ebe","title":"<font color=\"#c41230\">2.&nbsp; 执行中不会被其他的命令插入，不允许加塞行为</font>","parent":"7108ebeb6353","children":[]}],"parent":"5f404152c122"},{"id":"1563d9000f85","title":"事务执行的三个阶段","children":[{"id":"dee2f2edcb38","title":"开始事务","children":[],"parent":"1563d9000f85"},{"id":"516d871c1e80","title":"命令入队","children":[],"parent":"1563d9000f85"},{"id":"f623c01e7862","title":"事务执行","children":[],"parent":"1563d9000f85"}],"parent":"5f404152c122"}],"parent":"fd794deca5dd","collapsed":false},{"id":"bae6079d1e69","title":"命令","parent":"fd794deca5dd","children":[{"id":"4eb08a29a036","title":"DICARD","parent":"bae6079d1e69","children":[{"id":"46f0dbe2d96c","title":"取消事务","parent":"4eb08a29a036","children":[]}]},{"id":"890ad5b57b50","title":"EXEC","children":[{"id":"f283ebde8784","title":"执行所有事务块呢的命令","children":[],"parent":"890ad5b57b50"}],"parent":"bae6079d1e69"},{"id":"52da52d6f47f","title":"MULTI","parent":"bae6079d1e69","children":[{"id":"78d1689a7795","title":"标记一个事务块的开始","parent":"52da52d6f47f","children":[]}]},{"id":"3f7256e1fa2b","title":"UNWATCH","parent":"bae6079d1e69","children":[{"id":"d520d49f551d","title":"取消 WATCH 命令对所有 key 的监视","parent":"3f7256e1fa2b","children":[]}]},{"id":"898cd2d0bb55","title":"WATCH key [key ...]","parent":"bae6079d1e69","children":[{"id":"91738c6d47a5","title":"监视一个或多个 key , 如果在事务执行之前（或这些）key 被其他命令锁改动那么事务将被打断","parent":"898cd2d0bb55","children":[]}]}],"collapsed":false},{"id":"3b7e7b625708","title":"示例","parent":"fd794deca5dd","children":[{"id":"88095c28d0e5","title":"1. MULTI EXEC","children":[{"id":"709e29e53d99","title":"A 账户向 B 账户转账 50 元（A - 50， B + 50）","parent":"88095c28d0e5","children":[]},{"id":"f79054ab4aeb","title":"1.&nbsp; Multi 命令开始，输入的命令都会一次进入命令队列中，但不会执行","parent":"88095c28d0e5","children":[]},{"id":"3569cfc21962","title":"2. 直到输入 Exec 后，Redis 会将之前队列中的命令依次执行","children":[],"parent":"88095c28d0e5"},{"id":"ce634333f9f8","title":"3. 完整命令","children":[],"parent":"88095c28d0e5","note":"```\n# 初始化\nset account:a 100\nset account:b 100\n\n# 金额变动\nmulti\nget account:a\nget account:b\ndecrby account:a 50\nincrby account:b 50\nexec\n\n# 执行输出\n1) &quot;100&quot;\n2) &quot;100&quot;\n3) (integer) 50\n4) (integer) 150\n```"}],"parent":"3b7e7b625708","collapsed":false},{"id":"6ef92729376f","title":"2. DISCARD 放弃队列","children":[{"id":"8ef0600a2959","title":"1. 输入 multi 命令开始，输入的命令都会依次进入命令队列汇总，但不会执行","children":[],"parent":"6ef92729376f"},{"id":"118b4aa5c94a","title":"2. 直到输入 Exec 后，Redis 会将之前的命令队列中的命令依次执行","parent":"6ef92729376f","children":[]},{"id":"0b9a14737364","title":"3. 命令队列的过程也可以通过 discard 来放弃队列的运行","children":[],"parent":"6ef92729376f"},{"id":"27946e066ccf","title":"命令示例","children":[],"parent":"6ef92729376f","note":"```\n# 金额变动\nmulti\nget account:a\nget account:b\ndecrby account:a 50\nincrby account:b 50\ndicard\n\n# 执行输出\n[无输出]\n```"}],"parent":"3b7e7b625708"},{"id":"b99689988a5d","title":"3. 事务的错误处理","children":[{"id":"059bca1095fc","title":"<font color=\"#c41230\">如果执行了某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚</font>","parent":"b99689988a5d","children":[]},{"id":"7fb84e65d9fd","title":"命令示例","parent":"b99689988a5d","children":[],"note":"```\n# 执行命令\nmulti\nset hello hello\nincr hello \nget hello\nexec\n\n# 执行输出\n1) OK\n2) (error) ERR value is not an integer or out of range\n3) &quot;hello&quot;\n```"}],"parent":"3b7e7b625708"},{"id":"fe5c6fa70ffd","title":"4. 事务的错误处理","children":[{"id":"680647a4aa45","title":"事务队列中的某个命令<font color=\"#c41230\">报告错误</font>，执行了整个所有队列都会被取消。","parent":"fe5c6fa70ffd","children":[]},{"id":"b409aa33273d","title":"命令示例","children":[],"parent":"fe5c6fa70ffd","note":"```\n# 执行命令\nmulti\nset k 112\nsss 111 \nexec\n\n# 执行输出\n(error) EXECABORT Transaction discarded because of previous errors.\n\n```"}],"parent":"3b7e7b625708"},{"id":"f318bd473fe7","title":"5. 事务的WATCH","children":[{"id":"a1b3243d1869","title":"WATCH&nbsp; key","parent":"f318bd473fe7","children":[{"id":"c37c14823bf4","title":"监视一个（或多个）key, 如果在事务执行这个（或这些）key 被其他命令所改动， 那么事务将被打断","parent":"a1b3243d1869","children":[]}]},{"id":"4fef118e1604","title":"<font color=\"#c41230\">需求：某一个账户在一个事务内进行操作，在提交事务之前，另一个进程对该账户进行操作</font>","children":[],"parent":"f318bd473fe7","note":"```\n# 执行命令 client1\nsatch acccount:a\n\nmulti\nincr account:a\nincr account:a\nexec \n\n# 执行命令 client2 （client1  exec 之前执行）\nset account:a 2\n\n# 执行结果 (事务执行失败)\n(nil)\n```"}],"parent":"3b7e7b625708","collapsed":false},{"id":"097f75f2c5f1","title":"6. UNWATCH","children":[{"id":"f8f32c6d66ca","title":"Redis Unwatch 命令用于取消 WATCH 命令对所有 key 的监视。<br>如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行的话，那就不需要再执行UNWATCH 了","parent":"097f75f2c5f1","children":[]}],"parent":"3b7e7b625708"}]},{"id":"f5b78ce06915","title":"应用场景","children":[{"id":"5227bfef8372","title":"一组命令必须同时都执行，或者都不执行。<br>我们想要保证一组命令在想执行过程中不被其他命令插入。","parent":"f5b78ce06915","children":[]},{"id":"58168743b1c3","title":"<font color=\"#c41230\">商品秒杀（活动）<br></font>转账活动","children":[],"parent":"f5b78ce06915"}],"parent":"fd794deca5dd"}],"parent":"ba6919495c44","icons":[{"text":"&#xe62a","index":"2","color":"rgb(113, 203, 45)","name":"priority"}],"note":"Redis 事务可以一次执行多个命令（按照顺序地串行化执行，执行中不会吧其他命令插入不许加塞）","collapsed":false},{"id":"a9178ea00747","title":"Rediscover数据淘汰策略 redis.conf","children":[{"id":"edb7b78f8b29","title":"<b>最大缓存配置</b>","parent":"a9178ea00747","children":[{"id":"2ca5afb210b6","title":"在Redis 中，允许用户设置最大的内存大小","parent":"edb7b78f8b29","children":[]},{"id":"eb4138a6d9b9","title":"maxmemory 512G","parent":"edb7b78f8b29","children":[]}]},{"id":"c98a951cfe6b","title":"redis 提供的 8 种数据淘汰策略","children":[{"id":"ef0b2a9eebf3","title":"1. volatile-lru","children":[{"id":"1d044738225d","title":"设定超时时间的数据中，删除最不常用的数据","parent":"ef0b2a9eebf3","children":[]}],"parent":"c98a951cfe6b"},{"id":"37fcd3a32bbd","title":"2.&nbsp;allkeys-lru","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(80, 194, 139)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"c98a951cfe6b","children":[{"id":"d42cfb76b285","title":"查询所有的key 中最不常使用的数据进行删除，这是应用最广泛的策略","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[],"parent":"37fcd3a32bbd"}]},{"id":"a50fc8c8f65c","title":"3.&nbsp;volatile-random","children":[{"id":"a6734add132a","title":"在已经设定了超时的数据中随机删除","children":[],"parent":"a50fc8c8f65c"}],"parent":"c98a951cfe6b"},{"id":"ddf1fdb22174","title":"4.&nbsp;allkeys-random","parent":"c98a951cfe6b","children":[{"id":"1e51797bb50c","title":"查询所有的 key 之后随机删除","children":[],"parent":"ddf1fdb22174"}]},{"id":"5751bf476cf6","title":"5. volatile-ttl","parent":"c98a951cfe6b","children":[{"id":"0a44e7a5e71d","title":"查询全部设定超时时间的数据，追后马上排序，将马上将要过期的数据进行删除操作","children":[],"parent":"5751bf476cf6"}]},{"id":"f654cc16609e","title":"6.&nbsp;noeviction (默认)","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(255, 83, 92)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"c98a951cfe6b","children":[{"id":"15389c8df940","title":"如果设置为该属性，则不会进行删除操作，如果内存溢出则报错返回","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[],"parent":"f654cc16609e"}]},{"id":"660a62bbac5f","title":"7. volatile-lfu","children":[{"id":"025d788c80fd","title":"从所有配置了过期的时间的键中驱逐使用频率最少的键","parent":"660a62bbac5f","children":[]}],"parent":"c98a951cfe6b"},{"id":"3c643864fc34","title":"8. allkeys-lfu","parent":"c98a951cfe6b","children":[{"id":"e567e945cab9","title":"从所有键中驱逐使用频率最少的键","parent":"3c643864fc34","children":[]}]},{"id":"73cebca6eaf7","title":"<font color=\"#c41230\">建议：了解Redis 的淘汰策略之后，在平时使用尽量主动设置/更新 key 的 expire 时间<br>主动提出不活跃的旧数据， 有助于提升查询性能</font>","parent":"c98a951cfe6b","children":[]}],"parent":"a9178ea00747","note":"内存管理的一种页面置换算法，对于在内存中，但又不用的数据块（内存块）叫做LRU， 操作系统会更具哪些数据属于 LRU而将其移除内存而腾出空间来加载另外的数据。\n"}],"parent":"ba6919495c44","icons":[{"text":"&#xe635","index":"3","color":"rgb(255, 159, 26)","name":"priority"}],"note":"Redis 官方给出警告， 当内存不足是，Redis 会更具配置的缓存策略淘汰部分 keys ， 以保证写入成功。当无淘汰策略活没有找到适合淘汰策略的key 时， Redis 直接返回 out of memory  错误\n","collapsed":false},{"id":"1632c5ec217c","title":"Redis 持久化","children":[{"id":"c4c84bdf371c","title":"RDB（默认机制）","parent":"1632c5ec217c","children":[{"id":"543f5bbefa05","title":"是什么","parent":"c4c84bdf371c","children":[{"id":"945e543eb5b2","title":"RDB相当于快照，保存的是一种状态几十G数据 -&gt; 几KB的快照","parent":"543f5bbefa05","children":[]},{"id":"b3c0035f9d30","title":"快照是默认的持久化方式，这种方式是将内存中的数据以快照的方式<br>写入到二进制的文件中，默认的文件名是 dump.rdb<br>","parent":"543f5bbefa05","children":[]}]},{"id":"27e0ad797f05","title":"优缺点","parent":"c4c84bdf371c","children":[{"id":"4cc228d3491f","title":"<span style=\"font-size: inherit;\">优点</span><br>","parent":"27e0ad797f05","children":[{"id":"57282a4c4d7f","title":"快照保存数据极快、还原数据极快","parent":"4cc228d3491f","children":[]},{"id":"dd6aa0f46a60","title":"适用于灾备","parent":"4cc228d3491f","children":[]}]},{"id":"077e1296ba53","title":"缺点","parent":"27e0ad797f05","children":[{"id":"22f0fc207b63","title":"小内存的机器不适合使用","children":[],"parent":"077e1296ba53"}]}]},{"id":"4e451fe7cf05","title":"快照的条件","children":[{"id":"e510ab30c49f","title":"1. 服务器正常关闭时","children":[{"id":"28e0a591ba6a","title":"./bin/redis-cli shutdown","children":[],"parent":"e510ab30c49f"}],"parent":"4e451fe7cf05"},{"id":"7a09fb0b72d3","title":"2. key 满足一定条件会进行快照","children":[{"id":"7db40e7aa117","title":"vim redis.conf (搜索 save)","children":[],"parent":"7a09fb0b72d3","note":"```\n# 每900秒（15分钟）至少1个key发生变化产生快照\nsave 900 1\n# 每300秒（5分钟）至少10个key发生变化，产生快照\nsave 300 10\n# 每60秒（1分钟）至少10000个key发生变化，产生快照\nsave 60 10000\n```"}],"parent":"4e451fe7cf05"}],"parent":"c4c84bdf371c"}]},{"id":"749146f46d7e","title":"AOF","children":[{"id":"e18c3cd348e8","title":"是什么","children":[],"parent":"749146f46d7e","note":"由于快照方式在一定间隔时间内做一次，所以如果 redis 意外down 掉的话，就会丢失最后一次快照的所有修改，如果应用要求不呢个丢失任何修改的话，可以采用 AOF 方式。\n\nAppend-only file: AOF 比快照方式有更好的持久化， 是由于在 AOF 持久化方式时， redis 会将每一个收到的命令都通过write 函数最佳到文件中（默认是 appendonly.aof）当 redis 重启时会通过重新执行文件中保存的写命令来重建内存中整个数据库的内容。"},{"id":"e35b51b3bc36","title":"配置的三种方式（默认每秒 sync 一次）","parent":"749146f46d7e","children":[{"id":"0b470a8f9bd8","title":"&nbsp;启用AOF 持久化发方式","parent":"e35b51b3bc36","children":[{"id":"93af360c2add","title":"appendonly yes&nbsp;","children":[],"parent":"0b470a8f9bd8"}],"collapsed":false},{"id":"10b537efb7ab","title":"1. 收到写命令就立即写入磁盘，最慢，但是保证完全的持久化","children":[{"id":"37d85792ff07","title":"appendfsync always","children":[],"parent":"10b537efb7ab"}],"parent":"e35b51b3bc36"},{"id":"cbe23f3b4863","title":"2. 每秒钟写入磁盘一次，在能能和持久化方面做了很好的折中","parent":"e35b51b3bc36","children":[{"id":"2fe087957bbe","title":"appendfsync everysec","parent":"cbe23f3b4863","children":[]}]},{"id":"6351a71a5100","title":"3. 完全依赖OS， 性能好，持久化没有保障","parent":"e35b51b3bc36","children":[{"id":"d4d9fca5f582","title":"appendfsync no","children":[],"parent":"6351a71a5100"}]}]},{"id":"4874a3e01ab0","title":"产生的问题","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"749146f46d7e","children":[{"id":"9e07f67c2c42","title":"<font color=\"#f1753f\">AOF 的方式也同时带了了另外一个问题。持久化文件会越来越大。<br>例如我们调用incr test 命令100次，文件必须保存全部命令，那么其中有99条命令都是多余的。</font><br>","parent":"4874a3e01ab0","children":[]}]}],"parent":"1632c5ec217c"}],"parent":"ba6919495c44","icons":[{"text":"&#xe626","index":"4","color":"rgb(48, 191, 191)","name":"priority"}],"note":"数据存储：\n内存：高效、断电（关机）内存数据会丢失。\n硬盘：读写速度慢与内存，断电数据不会丢失。\n","collapsed":false},{"id":"6e5be5a11c48","title":"Redis 缓存与DB一致性","children":[{"id":"ce756ad571e8","title":"解决方案","children":[{"id":"72a7a04babc7","title":"1. 实时同步","children":[{"id":"1286f19094bd","title":"对要求强一致性比较高的，应采用实时同步方案，即查询缓存查询不到再从DB查询，保存到缓存<br>更新缓存时，先更新数据库，再将缓存的设置过期（建议不要去更新缓存内容，直接设置缓存过期）","parent":"72a7a04babc7","children":[]},{"id":"d4ffe3392ca7","title":"@Cacheable： 查询使用，注意Long 类型需要转换为String类型， 否者会抛异常<br>@CachePut: 更新使用，使用此注解，一定会从 DB上查询数据<br>@CacheEvict: 删除使用<br>@Caching: 组合用法<br>","parent":"72a7a04babc7","children":[]},{"id":"e6ecfce0b00f","title":"如果数据修改了，缓存也要修改<br>修改缓存数据或让缓存KEY失效","children":[],"parent":"72a7a04babc7"},{"id":"1706e2ddd058","title":"热点数据（缓存穿透）","parent":"72a7a04babc7","children":[{"id":"8fe9b96f271b","title":"中国奥运会金牌数量？","parent":"1706e2ddd058","children":[]},{"id":"ce891e93322e","title":"查询数据库，并将 KEY 设置进入 （查询数据库的时候需要加锁）","children":[],"parent":"1706e2ddd058"},{"id":"a017336316ec","title":"如果存在，直接查询可以","children":[],"parent":"1706e2ddd058"}]}],"parent":"ce756ad571e8"},{"id":"fac0ac037c26","title":"2. 异步同步","parent":"ce756ad571e8","children":[{"id":"a81bc05ed3ef","title":"对于并发程度较高的，采用一步队列的方式同步，可采用 Kafka 等消息中间件来处理消息的生产和消费。","parent":"fac0ac037c26","children":[]}]},{"id":"576e02671154","title":"3. 采用阿里的同步工具canal","parent":"ce756ad571e8","children":[{"id":"836333e0ac2d","title":"cannal 实现方式是模拟 mysql slave 和 master 的同步机智，监控DB bitlog 的日志来更新触发缓存的更新， <br>此中方法可以释放开发者的双手，但在使用时有一些局限性。<br>","children":[],"parent":"576e02671154"},{"id":"e985ba3707e8","title":"工作原理","children":[{"id":"97e7d09b17de","title":"1. canal 模拟 mysql slave 的交互模式，伪装自己是 mysql slave ， 向mysql master 发送dump 协议","parent":"e985ba3707e8","children":[]},{"id":"953cf6bbdf47","title":"2. mysql master 收到 dump 请求，开始推送 binary&nbsp; log 给 salve (也是 canal)","parent":"e985ba3707e8","children":[]},{"id":"3f0972d3d639","title":"3. canal 解析 binary log 对象（原始为 byte 流）","children":[],"parent":"e985ba3707e8"}],"parent":"576e02671154"}]},{"id":"489e53267944","title":"4.采用UDF自定义函数","parent":"ce756ad571e8","children":[{"id":"1309f5fc3a75","title":"面对 mysql 的 api 进行变成， 利用触发器进行缓存同步， 但是 UDF 主要是 C/C++语言实现学习成本较高","children":[],"parent":"489e53267944"}]}],"parent":"6e5be5a11c48"}],"parent":"ba6919495c44","icons":[{"text":"&#xe62b","index":"5","color":"rgb(68, 68, 68)","name":"priority"}]},{"id":"a3f6463acc29","title":"总结","parent":"ba6919495c44","children":[{"id":"663388f8c9bf","title":"1. 穿透","children":[{"id":"b82299c0caad","title":"是什么？","parent":"663388f8c9bf","children":[{"id":"dc90e109201f","title":"缓存传统指的是查询一一定不存在的数据，由于缓存不命中时需要从数据库中查询，查询不到数据则不写入缓存，<br>则不写入缓存，浙江到这这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透","parent":"b82299c0caad","children":[]}]},{"id":"ef3a5c241694","title":"如何处理？","children":[{"id":"b09701b3b634","title":"持久层查询不到就缓存空结果， 查询时先判断缓存是否 exists(key) ， 如果有直接放回空，么有则查询后返回。","children":[],"parent":"ef3a5c241694"},{"id":"9ca325cdc422","title":"注意 insert 时需要清除好查询的 key , 否则即便DB中查询有值也查询不到（当让也可以设置缓存的过期时间）","children":[],"parent":"ef3a5c241694"}],"parent":"663388f8c9bf"}],"parent":"a3f6463acc29"},{"id":"993d9c707bc4","title":"2. 雪崩","parent":"a3f6463acc29","children":[{"id":"24028feb8489","title":"是什么？","parent":"993d9c707bc4","children":[{"id":"138efa07ba02","title":"缓存大量失效的时候，引发大量查询数据库","children":[],"parent":"24028feb8489"}]},{"id":"0ee09b81900f","title":"如何处理？","children":[{"id":"14953ed69465","title":"1. 用锁/分布式锁或者队列串行访问","children":[],"parent":"0ee09b81900f"},{"id":"dd35e592892d","title":"2. 缓存失效时间均匀分布","parent":"0ee09b81900f","children":[]}],"parent":"993d9c707bc4"}]},{"id":"9762913b86b3","title":"3. 热点key","children":[{"id":"412bd8dfc228","title":"是什么？","parent":"9762913b86b3","children":[{"id":"6da0587c4ffe","title":"某个key 的访问频率非常频繁，当 key 失效的时候有大量线程来构建缓存，导致复杂增加，系统崩溃","children":[],"parent":"412bd8dfc228"}]},{"id":"553132bae871","title":"如何处理？","children":[{"id":"5682eb4271e9","title":"1. 使用锁， 单机使用sychronized，lock 等，分布式系统采用分布式锁","children":[],"parent":"553132bae871"},{"id":"4f38f98d44b2","title":"2. 缓存过期时间不设置， 而是设置在 key 对应的 value 里。如果检测到存的时间超过过期时间则一步更新缓存。","children":[],"parent":"553132bae871"},{"id":"a9a402ef1386","title":"3. 在 value 设置一个比过期时间 t0 小，过期时间 他 ， 当t1 过期时候，延长 t0 并做更新缓存操作。","children":[],"parent":"553132bae871"},{"id":"ad40fc37f504","title":"<font color=\"#c41230\">4. 设置标签缓存，标签缓存设置过期时间，标签缓存过期后，需一步地更新实际缓存</font>","parent":"553132bae871","children":[]}],"parent":"9762913b86b3"}],"parent":"a3f6463acc29"}],"icons":[{"text":"&#xe627","index":"6","color":"rgb(48, 191, 191)","name":"priority"}]}],"summaries":[],"icons":[{"text":"&#xe635","index":"3","color":"rgb(48, 191, 191)","name":"priority"}],"collapsed":false},{"id":"4048247f756d","title":"Redis 高并发/高可用","children":[{"id":"3b1d0de2bd5e","title":"1. Redis 存在的问题 ?","parent":"4048247f756d","children":[{"id":"0cb9e797defa","title":"一般来说要将 Redis 运用到工程中， 只是用一台 Redis 是万万不能，原因如下：","parent":"3b1d0de2bd5e","children":[]},{"id":"053c235de31d","title":"1. 从结构上， 单个 Redis 服务器会发生<font color=\"#c41230\">单点故障</font>， 并且一台服务器需要处理所有的请求负载，压力较大。","children":[],"parent":"3b1d0de2bd5e"},{"id":"94fc3d0b7133","title":"2. 从容量上， 单个 Redis 服务其内存容量有限，就算一台 Redis 服务器内容容量 256G， <br>也不能将所有的内容用作 Redis 存储内存， 一般来说单台的最大使用内存不应该超过 20G<br>","parent":"3b1d0de2bd5e","children":[]}],"collapsed":true},{"id":"629d4d3a6d29","title":"2. 高并发基本概述","children":[{"id":"284f9489fa93","title":"1. 高可用","children":[{"id":"9037d5809fad","title":"“高可用” （High Availability）通常来面试一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。","parent":"284f9489fa93","children":[]}],"parent":"629d4d3a6d29"},{"id":"8af94a784a51","title":"2. 高并发","children":[{"id":"d0c5c19430b2","title":"高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，<br><font color=\"#c41230\">通过设计保证系统能够同时并行处理很多请求。</font><br>","children":[],"parent":"8af94a784a51"},{"id":"e147ca45bcbb","title":"并发相关的指标有：<font color=\"#c41230\">相应时间（Response Time）、吞吐量（Troughput）、<br>每秒查询率 QPS （Query Per Second）</font>，并发用户等。<br>","parent":"8af94a784a51","children":[]},{"id":"c958eabbee50","title":"响应时间","children":[{"id":"cfec8d242a9a","title":"系统请求作出的响应时间。例如系统处理一个 HTTP 请求需要 200ms , 这就是系统的响应时间","children":[],"parent":"c958eabbee50"}],"parent":"8af94a784a51"},{"id":"cfa5b1067854","title":"吞吐量","children":[{"id":"c86e6c855bda","title":"单位时间内处理的请求数量","children":[],"parent":"cfa5b1067854"}],"parent":"8af94a784a51"},{"id":"d2b14cd0a32b","title":"每秒查询率 QPS","children":[{"id":"e01c0b9ccf69","title":"每秒响应请求数，在互联网领域，这个指标和吞吐量区分的没有这么明显","children":[],"parent":"d2b14cd0a32b"}],"parent":"8af94a784a51"},{"id":"c32845c49b20","title":"并发用户数","parent":"8af94a784a51","children":[{"id":"6e081f9d8338","title":"同时曾丹正航使用系统功能的用户数量。例如一个即时通讯系统，同时在线里那个一定程度代表了系统的并发用户数。","parent":"c32845c49b20","children":[]}]}],"parent":"629d4d3a6d29"},{"id":"4c2bd90f6b82","title":"3. 提升系统的并发能力","parent":"629d4d3a6d29","children":[{"id":"bd961d19a109","title":"提高系统并发能力的方式，方法论上主要有两种：","parent":"4c2bd90f6b82","children":[{"id":"c05c184228d5","title":"1. 垂直拓展（Scal UP）","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"bd961d19a109","children":[{"id":"5e0caadf5373","title":"1. 增强当即硬件性能。","parent":"c05c184228d5","children":[{"id":"ff666d41292d","title":"例如：增加 CPU 核数如 32 核，升级更好的网卡如万兆， <br>升级更好的硬盘如 SSD，拓充硬盘容量如 2T， 拓充系统内存如 128G<br>","parent":"5e0caadf5373","children":[]}]},{"id":"729458fcf1b2","title":"2. 提升单机架构性能。","children":[{"id":"593735571fff","title":"例如： 使用 Cache 来减少 IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间。","children":[],"parent":"729458fcf1b2"}],"parent":"c05c184228d5"},{"id":"fd0e579a595f","title":"在互联网发展非常迅猛的早期， 如果预算不是问题，强烈建议使用&nbsp; “增加单机硬件性能”<br>的方式提升系统并发能力，因为这个阶段，公司的战略往往是发展业务抢时间，而“增强单机硬件性能”往往是最宽的方法。<br>","parent":"c05c184228d5","children":[]},{"id":"61857d6972a8","title":"总结：不管是提升单机硬件性能，还是提升单机架构性能，都有一个致命的不足，单机性能总是有极限的。<br>所以互联网分布式架构高并发总计解决方案还是水平拓展。<br>","parent":"c05c184228d5","children":[]}],"note":"垂直拓展：提升单据处理能力，垂直拓展的方式又有两种："},{"id":"1a3e3e95733b","title":"2. 水平拓展（Scale Out）","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","border-style":"none","background-color":"rgb(80, 194, 139)","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"bd961d19a109","children":[{"id":"9459dba65120","title":"就是增加服务器的数量，就能线性的拓充系统性能。水平拓展对系统架构设计是有要求的，<br>难点在于：如何架构各层进行水平拓展的设计<br>","parent":"1a3e3e95733b","children":[]}]}]}]}],"parent":"4048247f756d","collapsed":true},{"id":"a7540e420932","title":"3. Redis 主从复制","parent":"4048247f756d","children":[{"id":"b7f16a16d314","title":"简介","children":[{"id":"12c7961196a8","title":"应用场景： 电子商务往回走哪上面的商品，一般都是一次上传， 无数次浏览的，说专业一些就是 “多读少写”","parent":"b7f16a16d314","children":[]},{"id":"73ee451e94fe","title":"生么是主从复制？","children":[{"id":"29c0a3111edb","title":"一个 Redis 服务其可以有多个该服务的复制品， 这个服务器称为 Master， 其他的复制称为是 slaves","parent":"73ee451e94fe","children":[]}],"parent":"b7f16a16d314"}],"parent":"a7540e420932"},{"id":"743b05c2dbc2","title":"实现原理","children":[{"id":"54ac924ed0d6","title":"结构图","style":{"text-align":"center"},"image":{"w":436,"h":285,"url":"http://cdn.processon.com/5e761341e4b08b61572ddad7?e=1584800081&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:3Zxz3wXzGapuNrdlSITCdJOGzWo="},"children":[],"parent":"743b05c2dbc2"},{"id":"5a5821fa9e43","title":"如图所示， 我们将一台 Redis 服务其作为主库（Master）,其他的三台作为从库 （Slave）,<br>主库负责写数据，每次有数据更新豆浆更新的数据同步到它所有的从库，而从库只负责读数据。<br>这样依赖，就有2个好处：","parent":"743b05c2dbc2","children":[{"id":"c80cffa3ac74","title":"1. 读写分离，不仅可以提高服务器的负载能力，并且可以根据读请求的规模自由增加或者减少从库的数量","children":[],"parent":"5a5821fa9e43"},{"id":"64ce26097819","title":"2.&nbsp; 数据库复制成了好几份，就可算一台机器出现了故障，也可以使用其他的机器","children":[],"parent":"5a5821fa9e43"}]}],"parent":"a7540e420932"},{"id":"2671629651c0","title":"具体配置","children":[{"id":"fb2dc6bc0ced","title":"在 Redis 中，要实现主从复制架构非常简单，只需要在从数据库的配置文件中增加如下命令即可：","parent":"2671629651c0","children":[]},{"id":"8aae367f344c","title":"1. 主数据库不需要任何陪孩子，创建一个从数据库","children":[{"id":"4d89e7a32c3c","title":"-- port 6380","children":[{"id":"1b1fa9ea78aa","title":"从服务器的端口","children":[],"parent":"4d89e7a32c3c"}],"parent":"8aae367f344c"},{"id":"c2656d4c1802","title":"-- slaveof 127.0.0.1 6379","parent":"8aae367f344c","children":[{"id":"7dd63c72b78e","title":"指定主服务器","parent":"c2656d4c1802","children":[]}]},{"id":"d5f986f52ece","title":"完整命令：<font color=\"#c41230\">./bin/redis-server ./redis.conf --port 6380 --slaveof 127.0.0.1 6379<br></font>加上 slaveof 参数启动另一个 redis 实例作为从库，并且坚挺 6380 端口","children":[{"id":"0c292b74ca57","title":"./bin/redis-server ./redis.conf --port 6380 --slaveof 127.0.0.1 6379","parent":"d5f986f52ece","children":[]}],"parent":"8aae367f344c"}],"parent":"2671629651c0"},{"id":"57423ff320ac","title":"2. 登录到从服务器客户端","parent":"2671629651c0","children":[]},{"id":"f826a0dc6362","title":"变回主： slaveof on one // 不是任何从","children":[],"parent":"2671629651c0"},{"id":"23c969efd3d3","title":"变回从：slaveof if 地址 端口号","parent":"2671629651c0","children":[]}],"parent":"a7540e420932","collapsed":true}],"collapsed":true},{"id":"2d077fb8599d","title":"4 .Redis Cluster 集群","children":[{"id":"3e40c0055b38","title":"简介","parent":"2d077fb8599d","children":[{"id":"2c16468132d7","title":"为什么使用集群？","children":[],"parent":"3e40c0055b38"},{"id":"8ff0a4fe9d7a","title":"为了在大流量访问下提供稳定的业务，集群化是存储的必然形态","parent":"3e40c0055b38","children":[]},{"id":"9b74f88da606","title":"未来的发展趋势肯定是云计算和大数据的紧密结合","children":[],"parent":"3e40c0055b38"},{"id":"73702fd29398","title":"只有分布式架构才能满足需求","parent":"3e40c0055b38","children":[]}],"collapsed":false},{"id":"948f319bd66d","title":"集群的方案","parent":"2d077fb8599d","children":[{"id":"757d52cfce8f","title":"1. Twitter&nbsp; 开发的 twemproxy","parent":"948f319bd66d","children":[]},{"id":"aede23d051fe","title":"2. 豌豆荚开发的 codis","parent":"948f319bd66d","children":[]},{"id":"9429d4c0f57d","title":"3. redis 官方的 redis-cluster","parent":"948f319bd66d","children":[]},{"id":"5b4a776c5537","title":"总结：Redis 集群大家的方式有很多种， 但是从&nbsp; redis 3.0 之后版本支持 redis-cluster 集群。<br><font color=\"#c41230\">至少需要 3（Master） + 3 （Slave）才能建立集群。</font><font color=\"#381e11\"> Redis-Cluster 采用</font><font color=\"#c41230\">无中心结构</font><font color=\"#381e11\">，<br>每个绩点保存数据和整个集群状态，每个节点都和其他所有节点链接，其 redis-cluster 架构图如下所示。</font><br>","parent":"948f319bd66d","children":[]},{"id":"72cd740ab5e9","title":"redis-cluster 架构图","image":{"w":273,"url":"http://cdn.processon.com/5e761b56e4b03b996529d830?e=1584802150&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:mVAjFLNkttTRIwCRtbERfORx0cY=","h":162},"children":[],"parent":"948f319bd66d"}],"collapsed":false},{"id":"2bc550d2d9f4","title":"集群的特点","children":[{"id":"6c9f3eb871c3","title":"1. 所有的节点彼互联 PING - PONG 机制， 内部采用二进制协议优化传输速度和带宽","parent":"2bc550d2d9f4","children":[]},{"id":"bcb216d6c889","title":"2. 节点的 fail 是通过集群中超过半数的节点检测失效时才失效","children":[],"parent":"2bc550d2d9f4"},{"id":"fc290d40f369","title":"3. 客户端与 redis 直连，不需要中间 proxy 层， 客户端不需要连接集群所有节点， 连接集群中任何一个节点即可","parent":"2bc550d2d9f4","children":[]},{"id":"29011a645636","title":"4. redis-cluster&nbsp; 把所有的物理节点映射到 0-16383 slot 上（不一定时平均分配）cluster 负责维护","parent":"2bc550d2d9f4","children":[]},{"id":"4cb9faba4c85","title":"5. Redis 集群预分好 16384 个哈希槽， 当需要在 Redis 集群中放置一个 key-value 时，<br>redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数， 这样每个 key <br>都会对应一个编号在 0-16383 之间的哈希槽， redis 会更具节点数量大致均等的将哈希槽映射到不同的节<br>","parent":"2bc550d2d9f4","children":[]}],"parent":"2d077fb8599d","collapsed":false},{"id":"1cc072e6d33d","title":"redis-cluster 容错性","parent":"2d077fb8599d","children":[{"id":"02e124df9d4a","title":"<font color=\"#c41230\">容错性</font>，是指软件检测应用运行的软件或硬件中发生错误并错误中回复能力，<br>通常可能从系统的可靠性，可用性，可测性等几方面来衡量<br>","children":[],"parent":"1cc072e6d33d"},{"id":"0b1552300614","title":"redis-cluster 投票：容错","children":[{"id":"a40d36ed095f","title":"1. 投票过程是集群中所有 master 参与 ，如果半数以上 master 节点与 master 节点通讯超时 （master -node -timeout）<br>认为当前 master 节点挂掉","children":[],"parent":"0b1552300614"},{"id":"90b40fc36b76","title":"2. 什么时候整个集群不可用？（cluster_state:fail）","children":[{"id":"8b977a204bc7","title":"如果集群任意master 挂掉， 且当前 master 没有 slave .&nbsp; 集群进入 fail 状态，<br>也可以理解成集群的 slot 映射 [0 - 16383]&nbsp;不完整进入 fail 状态， <br>如果集群超过半数以上 master 挂掉， 无论是否有 slave , 集群进入 fail 状态。<br>","children":[],"parent":"90b40fc36b76"}],"parent":"0b1552300614"}],"parent":"1cc072e6d33d"}],"collapsed":false},{"id":"9b10e3be3af3","title":"redis-cluster 节点分配","children":[{"id":"11d2da94c890","title":"（官方推荐）三个绩点分别是 A，B，C三个阶段，他们可以是一台机器上的三个端口，<br>也可以是 三台不同的服务器。那么采用哈希槽（hash slot）的方式来分配 16384 个 slot 的化，<br>他们三个节点分别承担的 slot 区间是 ：<br>","parent":"9b10e3be3af3","children":[{"id":"206f02b83e05","title":"节点 A 覆盖 0- 5460","parent":"11d2da94c890","children":[]},{"id":"27dc1cd81f07","title":"节点 B 覆盖 5461 - 10922","children":[],"parent":"11d2da94c890"},{"id":"b0b10146f11a","title":"节点C 覆盖 10923 - 16383","parent":"11d2da94c890","children":[]},{"id":"97d2f737dfbe","title":"如果有新增节点","children":[{"id":"bca9ec7cac67","title":"新增节点 D redis-cluster 的这种做法是从各个节点前面各取一部分 slot 到 D上","children":[],"parent":"97d2f737dfbe"},{"id":"eb937ec30a07","title":"新增节点后","parent":"97d2f737dfbe","children":[{"id":"0d25f7d63dce","title":"节点 A 覆盖 1365 - 5460","children":[],"parent":"eb937ec30a07"},{"id":"6d25f5fe3e10","title":"节点 B 覆盖 6827 - 10922","children":[],"parent":"eb937ec30a07"},{"id":"1a46b63eae2e","title":"节点 C 覆盖 12288 - 16383","parent":"eb937ec30a07","children":[]},{"id":"1f16fc4ef34d","title":"节点D&nbsp; 0 - 1364， 5461 - 6826，10923 - 12287&nbsp;","parent":"eb937ec30a07","children":[]}]}],"parent":"11d2da94c890"}]}],"parent":"2d077fb8599d","collapsed":false},{"id":"efdf5184cbc7","title":"redis-cluster 集群搭建","children":[{"id":"46bf866b0067","title":"简介","children":[{"id":"32a3798d7191","title":"集群中至少应该有奇数个绩点，所以搭建集群最少需要3台主机。同时每个节点至少有一个备份节点，<br>所以下面最少需要创建使用 6 台机器，才能完成 Redis-Cluster 集群（主节点、备份节点由 redis-cluster 集群确定）<br>","children":[],"parent":"46bf866b0067"}],"parent":"efdf5184cbc7"},{"id":"064145398512","title":"集群搭建流程","parent":"efdf5184cbc7","children":[{"id":"148ad4879d14","title":"1. 创建集群的安装目录","parent":"064145398512","children":[{"id":"5d8420db97b4","title":"mkdir -p /usr/local/redis_cluster","parent":"148ad4879d14","children":[]}]},{"id":"80b2810e3e66","title":"2. 在redis_cluster 目录下，创建 7001- 7006 个文件夹","parent":"064145398512","children":[{"id":"85e1f48f410e","title":"mkdir 7001 7002 7003 7004 7005 7006","children":[],"parent":"80b2810e3e66"}]},{"id":"f32671685913","title":"3. 并将 redis-cluster 分别拷贝到 7001-7006 文件夹下","children":[],"parent":"064145398512"},{"id":"ba5812f67fcf","title":"4. 分别修改如下配置文件， 修改如下内容<br>同时 protected-mode 为了禁止公网访问 redis cache , 加强redis 安全性，它的启用条件有两个：<br>","parent":"064145398512","children":[{"id":"f5b93db2ea68","title":"1) 没有绑定IP","parent":"ba5812f67fcf","children":[]},{"id":"c0af0f339e9a","title":"2） 没有设置访问密码","children":[],"parent":"ba5812f67fcf"},{"id":"68449c9662c3","title":"由于 Linux 上的 redis 处于安全保护模式， 这就让你无法从虚拟机外部去轻松建立链接。","parent":"ba5812f67fcf","children":[{"id":"ad87a6b8db3f","title":"如果外部无法访问：redis.conf 中设置保护模式为 protected-mode no","parent":"68449c9662c3","children":[]}]},{"id":"e78586ca9281","title":"修改的配置","parent":"ba5812f67fcf","children":[{"id":"d3dc4bd5a328","title":"bind 0.0.0.0","parent":"e78586ca9281","children":[{"id":"be5c7d9722b8","title":"绑定服务器的 IP","children":[],"parent":"d3dc4bd5a328"}]},{"id":"3cc17f25e7cb","title":"port 7001","parent":"e78586ca9281","children":[{"id":"2599cf6fd223","title":"绑定端口号","children":[],"parent":"3cc17f25e7cb"}]},{"id":"1fc48d61a8b7","title":"pidfile /var/run/redis-7001.pid","children":[{"id":"6c7db3fc26f4","title":"修改pid 进程文件名，以端口号命名","children":[],"parent":"1fc48d61a8b7"}],"parent":"e78586ca9281"},{"id":"1aac04629548","title":"logfile /root/application/program/redis-cluster/7001/redis.log","children":[{"id":"5a8af6b54e67","title":"修改日志文件名，用端口号来区分","children":[],"parent":"1aac04629548"}],"parent":"e78586ca9281"},{"id":"3fbfbcb069ba","title":"dir /root/appliaction/program/reid-cluster/7001/","parent":"e78586ca9281","children":[{"id":"bb8d4d303347","title":"修改数据文件存放的地址，以端口号为目录来区分","children":[],"parent":"3fbfbcb069ba"}]},{"id":"26d18431e773","title":"cluster-enabled yes","children":[{"id":"4343f096beb3","title":"启用集群","children":[],"parent":"26d18431e773"}],"parent":"e78586ca9281"},{"id":"b9514eae87d9","title":"cluster-config-file nodes-7001.conf","children":[{"id":"02bf45adfdfe","title":"配置每个绩点的配置文件，同样端口号为文件名","children":[],"parent":"b9514eae87d9"}],"parent":"e78586ca9281"},{"id":"3bfd82f96f6b","title":"cluster-node-timeout 15000","children":[{"id":"78c42c2d43cf","title":"配置集群节点的超时时间，可以不改变","children":[],"parent":"3bfd82f96f6b"}],"parent":"e78586ca9281"},{"id":"f03e2ff19367","title":"appendonly yes","children":[{"id":"8b27c11c046b","title":"启用AOF来增强持久化策略","children":[],"parent":"f03e2ff19367"}],"parent":"e78586ca9281"},{"id":"cc8edeab726b","title":"appednfsync always","children":[{"id":"0b010a2c494a","title":"发生改变就持久化策略","children":[],"parent":"cc8edeab726b"}],"parent":"e78586ca9281"},{"id":"b518765fecd6","title":"deamonize yes","children":[{"id":"5bc53f495f58","title":"后台与性能","children":[],"parent":"b518765fecd6"}],"parent":"e78586ca9281"}]}]},{"id":"98526e716369","title":"5. 启动各个 Redis 节点","children":[{"id":"0b8566b0ff6b","title":"将&nbsp;redis-x.x.x/ 下的 src 为难拷贝到各个 redis 7001 - 7006 目录下","parent":"98526e716369","children":[]},{"id":"ebb80b28e43a","title":"cd&nbsp;redis-x.x.x/","children":[],"parent":"98526e716369"},{"id":"c8841171b4a2","title":"<font color=\"#c41230\">cp -r ./src /usr/local/redis_cluster/7001</font> (拷贝到 7001 - 7006)","parent":"98526e716369","children":[]},{"id":"4157098bb3c3","title":"启动各个节点：","parent":"98526e716369","children":[]},{"id":"dcf8498421e1","title":"cd&nbsp;/usr/local/redis_cluster","parent":"98526e716369","children":[]},{"id":"4892827f480c","title":"<font color=\"#c41230\">./7001/src/redis-server ./7001/redis.conf</font> 依次启动 7001-7006","children":[],"parent":"98526e716369"}],"parent":"064145398512"}]},{"id":"4a241fc9102e","title":"创建集群(4.x 安装过于复杂)","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"children":[{"id":"23a5d363f2bb","title":"Redis 官方提供了一个 redis-trib.rb 这个工具，就在解压目录的 src 目录中<br>（为了方便操作）将其复制到 /usr/local/bin 目录下， 可以直接访问此命令<br>","children":[{"id":"03f228290121","title":"cd&nbsp;redis-x.x.x","parent":"23a5d363f2bb","children":[]},{"id":"2c0f08300435","title":"cd src&nbsp;","children":[],"parent":"23a5d363f2bb"},{"id":"f3ad05045296","title":"cp redis-trib.rb /usr/local/bin/","children":[],"parent":"23a5d363f2bb"}],"parent":"4a241fc9102e"},{"id":"741853f3b812","title":"直接在命令中执行： ip:port 格式","children":[{"id":"7c8d23c4899b","title":"<font color=\"#c41230\">redis-trib.rb create --replicas 127.0.0.1:7001&nbsp;127.0.0.1:7002&nbsp;127.0.0.1:7003&nbsp;127.0.0.1:7004&nbsp;127.0.0.1:7005&nbsp;127.0.0.1:7006</font>","parent":"741853f3b812","children":[]}],"parent":"4a241fc9102e"},{"id":"f8fcb41f0d1c","title":"如果出现这个错误","children":[{"id":"fc066f26683a","title":"/usr/bin/env: ‘ruby’: No such file or directory<br>需要安装 ruby","children":[{"id":"95f176f16e7b","title":"安装 ruby","children":[{"id":"bfdfc44a835f","title":"yum -y install ruby ruby-devel rubygems rpm-build","parent":"95f176f16e7b","children":[]},{"id":"072bd00b79d2","title":"gem install redis","children":[],"parent":"95f176f16e7b"}],"parent":"fc066f26683a"},{"id":"d3d4c828049a","title":"安装 rvm","children":[{"id":"5f49430278f7","title":"gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3","children":[],"parent":"d3d4c828049a"},{"id":"e14877d53b1d","title":"\\curl -sSL https://get.rvm.io | bash -s stable","children":[],"parent":"d3d4c828049a"},{"id":"79766e29647b","title":"source /usr/local/rvm/scripts/rvm","children":[],"parent":"d3d4c828049a"},{"id":"c6744d071c27","title":"rvm list known","children":[],"parent":"d3d4c828049a"},{"id":"2198b7dd4525","title":"find / -name rvm -print","children":[],"parent":"d3d4c828049a"}],"parent":"fc066f26683a"},{"id":"2fa71ade6acf","title":"升级 ruby","children":[{"id":"919fbfd7ed23","title":"rvm install 2.4.4","children":[],"parent":"2fa71ade6acf"},{"id":"6b7795167459","title":"rvm use 2.4.4","parent":"2fa71ade6acf","children":[]},{"id":"ec6928e353d8","title":"rvm use 2.4.4 --default","children":[],"parent":"2fa71ade6acf"},{"id":"2ce6e85552b0","title":"ruby --version","children":[],"parent":"2fa71ade6acf"},{"id":"de3cf7fc201d","title":"gem install redis","children":[],"parent":"2fa71ade6acf"}],"parent":"fc066f26683a"}],"parent":"f8fcb41f0d1c"}],"parent":"4a241fc9102e"}],"parent":"efdf5184cbc7","icons":[{"text":"&#xe693","index":"39","name":""}]},{"id":"bae9faeb7fae","title":"创建集群(推荐)","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"efdf5184cbc7","children":[{"id":"0f5f4341092f","title":"<font color=\"#c41230\">./redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1 -a&nbsp;Iredis8Pwd</font>","parent":"bae9faeb7fae","children":[]},{"id":"c01bef0f8047","title":"说明","children":[{"id":"e55f8ee7b011","title":"注：redis5版本可以直接使用redis-cli命令配置集群(内部集成ruby)<br><br>--cluster-replicas 1：表示主从比例1:1 (一台主机对应有一台从机)<br><br>--cluster-replicas 2：表示主从比例1:2 (一台主机对应有两台从机)<br><br>-a root123456：配置集群时所需的认证密码 (-a：auth简写，root123456：redis服务器认证密码）","children":[],"parent":"c01bef0f8047"}],"parent":"bae9faeb7fae"},{"id":"d6e301ddec39","title":"&nbsp;成功提示","parent":"bae9faeb7fae","children":[{"id":"e4cab821ccbe","title":"<font color=\"#16884a\">[OK] All nodes agree about slots configuration.</font><br>&gt;&gt;&gt; Check for open slots...<br>&gt;&gt;&gt; Check slots coverage...<br><font color=\"#16884a\">[OK] All 16384 slots covered.</font>","parent":"d6e301ddec39","children":[]}]}]}],"parent":"2d077fb8599d","collapsed":false},{"id":"b967fa54626c","title":"redis-cluster 测试","children":[{"id":"07a18a9525e3","title":"1. 复制 redis-cli 客户端到 /usr/local/bin 下","children":[{"id":"082e85bf7296","title":"cp redis-cli /usr/local/bin/","children":[],"parent":"07a18a9525e3"}],"parent":"b967fa54626c"},{"id":"6410e037516a","title":"2. 访问集群","children":[{"id":"56640135c85b","title":"redis-cli -h 127.0.0.1 -c -p 7001","children":[{"id":"fa259c428b89","title":"加参数 -C 可连接到集群。因为上面redis 将bind 修改为了 0.0.0.0 ，所以 -h 也是可以省略的","children":[],"parent":"56640135c85b"}],"parent":"6410e037516a"},{"id":"c0b418723159","title":"cluster nodes","children":[{"id":"ac247dbab688","title":"查询节点","parent":"c0b418723159","children":[]}],"parent":"6410e037516a","note":"```shell\n683dfa9b32bbcc87fd71644f2ba617dc178bf4e0 127.0.0.1:7006@17006 slave aa8873dff592ea713a6865b3b63703ad22ac9589 0 1584804320000 3 connected\n2deb608bb6eaba6afe9ba1a17feca98bd1774e1d 127.0.0.1:7002@17002 myself,master - 0 1584804322000 2 connected 5461-10922\naf6ecdcaed7932c335d553fe7183c72f5ac0b8e8 127.0.0.1:7004@17004 slave 57f5236ea91d7c8c94f0b3526de291faf339e2e1 0 1584804321000 4 connected\n700034ad0b12020629459b174ad41a87ca1d7733 127.0.0.1:7005@17005 slave 2deb608bb6eaba6afe9ba1a17feca98bd1774e1d 0 1584804321370 5 connected\naa8873dff592ea713a6865b3b63703ad22ac9589 127.0.0.1:7003@17003 master - 0 1584804323375 3 connected 10923-16383\n57f5236ea91d7c8c94f0b3526de291faf339e2e1 127.0.0.1:7001@17001 master - 0 1584804322374 1 connected 0-5460\n```\n\n&lt;font color=&quot;red&quot;&gt;\n每个 redis 大的节点都有一个ID 指，此ID 将被特定 redis 实例永久使用，一边在实例集群上下文中具有唯一的名称。每个节点都会记住此ID， 每个其他节点，而不是通过 IP 或者端口。 IP地址和端口可能发送变化，但是唯一的节点标示在节点的整个生命周期内都不会改变。我们简单的称这个标示符为 节点ID\n\n&lt;/font&gt;"},{"id":"4f0f88a49b1e","title":"小总结","parent":"6410e037516a","children":[],"note":"redis clouster 在设计的时候，就考虑到了去中心化， 去中间件，也就是说，集群中的每个节点都是和其他所有节点平等关系，都是对等的，每个节点都保存格子的数据和整个集群的状态，每个节点都和其他所有节点链接，而且这些链接保持活跃，这样我们就保证了我们只需要链接集群中的任意一个节点，就可以获取到其他的数据。\n"}],"parent":"b967fa54626c"},{"id":"bee584045b2a","title":"3. 测试截图","parent":"b967fa54626c","children":[],"image":{"w":544,"url":"http://cdn.processon.com/5e7633c7e4b03b996529fd3b?e=1584808407&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:TdFoi1LaQvqYdLjQ77V-2UM6KwQ=","h":211}}],"parent":"2d077fb8599d"}],"parent":"4048247f756d","collapsed":false},{"id":"358c4ad61c3b","title":"5. 高并发常见问题？","parent":"4048247f756d","children":[{"id":"832b7d37f81a","title":"缓存穿透","children":[{"id":"7bbebcfa7171","title":"介绍","parent":"832b7d37f81a","children":[{"id":"ff94131ea204","title":"<font color=\"#381e11\">缓存穿透个是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，<br>查不到数据则不写入缓存，这将导致这个不存在的数据每次都需要到数据库中去查询，造成缓存穿透</font><br>","parent":"7bbebcfa7171","children":[]}]},{"id":"1aa766275f43","title":"<b>解决方案</b>","parent":"832b7d37f81a","children":[{"id":"d9368292c21e","title":"持久层查询不到就缓存空结果， 查询时先判断缓存中是否 exists(key), 如果又直接放回空，没有则查询后返回","parent":"1aa766275f43","children":[]},{"id":"d803ba9efbda","title":"注意 insert 时需要清除查询的 key , 否则即便 DB 中有值也查询不到（当让也可以设置空缓存的过期时间）","parent":"1aa766275f43","children":[]}]},{"id":"10322f586500","title":"例子","children":[{"id":"5bc986391990","title":"1. 数据自增ID从0 开始， 如果查询 id = -1 的数据","children":[],"parent":"10322f586500"},{"id":"8cd5b8de2bd7","title":"2. 高并发 10000 人访问","parent":"10322f586500","children":[]},{"id":"08a47f7076bb","title":"3. 由于缓存中没有数据，所以每次都会去查询数据库。","parent":"10322f586500","children":[]},{"id":"38f0238ac795","title":"<span style=\"font-size: inherit;\"><font color=\"#c41230\">4. 如果数据库中查询出来为 null 可以缓存一个 \"\" 空字符串</font></span><br>","parent":"10322f586500","children":[]}],"parent":"832b7d37f81a"}],"parent":"358c4ad61c3b"},{"id":"c75921967aea","title":"缓存雪崩","children":[{"id":"c0eff3881225","title":"介绍","parent":"c75921967aea","children":[{"id":"19a44936c1c9","title":"如果缓存集中在一个时间段内失效，发生大量的缓存穿透，所有的查询都落到了数据库上，造成缓存雪崩。","children":[],"parent":"c0eff3881225"},{"id":"0719e9b1f5f4","title":"这个没有完美的解决办法，但是可以分析用户的行为，尽量让失效时间均匀分布。<br>大多数系统设计者考虑用加锁或队列的方式来把整缓存的单线程（进程）写，<br>从而避免失效时大量的并发请求落到底层的存储系统上<br>","children":[],"parent":"c0eff3881225"}]},{"id":"def2a9395180","title":"解决方案","parent":"c75921967aea","children":[{"id":"9511b915023d","title":"1. 加锁排队，限流算法。","parent":"def2a9395180","children":[{"id":"fd0c6f89e0b1","title":"计数","parent":"9511b915023d","children":[]}]},{"id":"d5454da31b0a","title":"2. 滑动窗口","parent":"def2a9395180","children":[]},{"id":"761a4002a35f","title":"3. 令牌桶 Token Bucket","parent":"def2a9395180","children":[]},{"id":"ac2b7e7a1acd","title":"4. 漏桶 leaky bucket","parent":"def2a9395180","children":[]}]},{"id":"6225c000ec1e","title":"总结","parent":"c75921967aea","children":[{"id":"49fcaae8ff73","title":"在缓存失效的时候，通过加锁或者队列来控制读数据库写缓存的线程数量。<br>比如对某个key只允许一个线程查询和写缓存，其他线程等待<br>","parent":"6225c000ec1e","children":[]}]}],"parent":"358c4ad61c3b"}],"collapsed":false}],"parent":"root","icons":[{"text":"&#xe626","index":"4","color":"rgb(113, 203, 45)","name":"priority"}],"collapsed":false},{"id":"6ae076ac4fa0","title":"Jedis 错误","children":[{"id":"900ac728ed7e","title":"No reachable node in cluster","children":[{"id":"18d857569b3c","title":"1.&nbsp;JedisNoReachableClusterNodeException：No reachable node in cluster","children":[],"parent":"900ac728ed7e"},{"id":"4c2c80dbb461","title":"2. 错误截图","parent":"900ac728ed7e","children":[{"id":"fa1cf11fcbc3","title":"截图","image":{"w":442,"url":"http://cdn.processon.com/5efdb6ad5653bb2925c64dbe?e=1593689277&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:KnxnAgf7JHui3e_OSj-r9TNOncI=","h":264},"children":[],"parent":"4c2c80dbb461"}]},{"id":"92ccb9365e6d","title":"3. 问题分析","children":[{"id":"03469a087a0c","title":"1. 无可用连接，可能是存在较多的连接占用，新请求无法获取连接","children":[],"parent":"92ccb9365e6d"}],"parent":"900ac728ed7e","collapsed":false},{"id":"e342010b678c","title":"4. 解决方案","parent":"900ac728ed7e","children":[{"id":"5aa977dd02a6","title":"增大连接数解决","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border-style":"none","border-color":"rgb(255, 255, 255)","border-width":"0px"},"parent":"e342010b678c","children":[]}],"note":"**\n      \nspring:\n  redis:\n    pool.max-active: 4096\n    pool.max-idle: 2024\n    pool.max-wait: 10000\n    pool.min-idle: 2\n    timeout: 600000\n**"}],"parent":"6ae076ac4fa0","collapsed":false}],"parent":"root","icons":[{"text":"&#xe62b","index":"5","name":"priority"}],"collapsed":true},{"id":"5ebcf13727c9","title":"Redis 分布式锁","children":[{"id":"d64ba2adfbf1","title":"RedLock","children":[{"id":"70a767f44b24","title":"1. 在没有&nbsp;fencing栅栏机制的前提下不安全","parent":"d64ba2adfbf1","children":[{"id":"e9a8d9f34ff9","title":"概述： 获取锁的客户端在持有锁时可能会暂停一段较长的时间，尽管锁有一个超时时间，避免了崩溃的客户端可能永远持有锁并且永远不会释放它，但是如果客户端的暂停持续的时间长于锁的到期时间，并且客户没有意识到它已经到期，那么它可能会继续进行一些不安全的更改，换言之由于客户端阻塞导致的持有的锁到期而不自知。","children":[],"parent":"70a767f44b24"},{"id":"cfa2a3e62407","title":"问题流程图","children":[],"parent":"70a767f44b24"},{"id":"c5028acc7563","title":"解决方案","children":[],"parent":"70a767f44b24"}]},{"id":"f4f2c913bb21","title":"子主题","parent":"d64ba2adfbf1","children":[]}],"parent":"5ebcf13727c9","collapsed":true}],"parent":"root","icons":[{"text":"&#xe627","index":"6","color":"rgb(191, 30, 27)","name":"priority"}],"collapsed":true}],"lines":{"13f2cb6a00d5":{"id":"13f2cb6a00d5","to":"7c8d23c4899b","realStart":{"y":16895.375,"x":11261.28125},"start":{"index":2,"y":"0.0","x":"0.5"},"styles":{"lineColor":"rgb(113, 203, 45)","color":"#ffffff","lineWidth":1},"realEnd":{"y":16716.390625,"x":11569.421875},"label":"安装完成后再执行&nbsp; redis-trib","from":"fc066f26683a","points":[{"y":14200.1484375,"x":11418.8359375},{"y":14202.6640625,"x":11418.8359375}],"pts":[{"y":-2715.7265625,"x":157.5546875},{"y":-2501.2265625,"x":-150.5859375}],"end":{"index":4,"y":"1.0","x":"0.5"},"angle":266.57176717468445},"bfe4783df06a":{"to":"f7a4af6838b8","id":"bfe4783df06a","realStart":{"y":7035.453125,"x":10782.1875},"start":{"index":3,"y":"1.0","x":"0.5"},"realEnd":{"y":7043.09375,"x":10802.5875},"styles":{"lineColor":"rgb(113, 203, 45)","color":"#ffffff","lineWidth":1},"points":[{"y":6800.234283447266,"x":10839.499816894531},{"y":6812.374908447266,"x":10841.499816894531}],"from":"1528f8699911","angle":279.57323444037445,"end":{"index":1,"y":"0.0","x":"0.4"},"pts":[{"y":-222.71884155273438,"x":57.31231689453125},{"y":-269.2188415527344,"x":-17.68768310546875}]}},"note":"* 学习视频地址：\nhttps://www.bilibili.com/video/av49517046\n\n* github demo 代码地址\n"}},"meta":{"id":"5fb538e71e085368771bcdef","member":"5d6289b7e4b0ac2b61862719","exportTime":"2020-11-18 23:10:08","diagramInfo":{"category":"mind_free","title":"Redis数据库","created":"2020-11-18 23:08:23","creator":"5d6289b7e4b0ac2b61862719","modified":"2020-11-18 23:09:35"},"type":"ProcessOn Schema File","version":"1.0"}}