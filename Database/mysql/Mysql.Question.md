# 关于Mysql的问题
1. “N叉树”的N值在MySQL中是可以被人工调整的么？
    - 5.6以后可以通过page大小来间接控制
2. 没有主键的表，只有普通索引怎么回标？
    - 没有主键的表，innodb会给默认创建一个Rowid做主键
3. innodb B+树主键索引的叶子节点存的是什么？
    - B+树的叶子节点是page （页），一个页里面可以存多个行
4. 如果你要删除一个表里面的前 10000 行数据, 有以下三种方案
   1. 第一种，直接执行 delete from T limit 10000;
   2. 第二种，在一个连接中循环执行 20 次 delete from T limit 500;
   3. 第三种，在 20 个连接中同时执行 delete from T limit 500。
   - 分析如下: 
      - 方案一，事务相对较长，则占用锁的时间较长，会导致其他客户端等待资源时间较长。
      - 方案二，串行化执行，将相对长的事务分成多次相对短的事务，则每次事务占用锁的时间相对较短，其他客户端在等待相应资源的时间也较短。这样的操作，同时也意味着将资源分片使用（每次执行使用不同片段的资源），可以提高并发性。
      - 方案三，人为自己制造锁竞争，加剧并发量。
5. optimize table、analyze table 和 alter table的区别？
   1. alter table t engine = InnoDB（也就是 recreate）
   2. analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；
   3. optimize table t 等于 recreate+analyze。
6. MySQL 怎么知道 binlog 是完整的?
   1. 一个事务的 binlog 是有完整格式的：
      - statement 格式的 binlog，最后会有 COMMIT；
      - row 格式的 binlog，最后会有一个 XID event;
   2. MySQL 5.6.2 版本后, binlog-checksum 参数验证 binlog 内容的正确性。
7. redo log 和 binlog 是怎么关联起来的?
   1. 有一个共同的数据字段XID，崩溃恢复的时候，会按顺序扫描 redo log，
      - 如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；
      - 如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。
      

7. 表的逻辑结构 ，表 —> 段 —> 段中存在数据段(leaf node segment) ，索引段( Non-leaf node segment）,请问数据段就是主键索引的数据， 索引段就是二级索引的数据么
8. 建立的每个索引都有要维护一个数据段么 ？？ 那么新插入一行值 ， 岂不是每个索引段都会维护这个值
9. 索引的n阶表示n个数据页么。那是不是插入第一行数据树高1 ，就是一个数据页， 插入二三行，树高是二，那就是两个数据页，而且B+树只有leaf node存数据，所以父节点实际上有没有数据，但是占一个页 ，好浪费 ， 是我理解有误么
10. 树高取决于数据页的大小么 ， 这个不是很能理解 ，数据页为16k 。 那么树高不是一个定值了么，难道还和里面存数据的大小有关么
11. 查询数据的时候，大致的流程细化来说 ,我这么理解对么 。 通过优化器到表里的数据段／索引段取数据 ，数据是按照段->区->页维度去取 ， 取完后先放到数据缓冲池中，再通过二分法查询叶结点的有序链表数组找到行数据返回给用户 。 当数据量大的时候，会存在不同的区，取范围值的时候会到不同的区取页的数据返回用户。

这块知识有点比较难理解，看书和一些文章的时候也比较晦涩，希望老师能解答下，感觉这块啃不透 是不是索引设计起来就比较吃力
1. 这样理解也算对，不过要记得 主键也是索引的一种哈
2. 是的，所以说索引越多，“维护成本”越大
3. 如果是几百个儿子节点共用一个父节点，是不是就不会看上去那么浪费啦
4. 树高其实取决于叶子树（数据行数）和“N叉树”的N。 而N是由页大小和索引大小决定的。
5. 基本是你说的流程。不过不是“优化器”去取的，是执行器调用引擎，引擎内部才管理了你说的 段、页这些数据