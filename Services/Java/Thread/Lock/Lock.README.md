## Java 锁事
1. 锁的作用？
    1. 多线程情况下，可能存在多个线程同时操作统一资源情况下，导致资源(数量、状态)值信息线程间数据信息不一致的情况(个人见解)。
## 锁的种类:
1. 公平锁/非公平锁
    1. 公平锁: 公平锁是指多个线程按照申请锁的顺序来获取锁。
    2. 非公平锁: 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。
    3. Java中常见公平锁/非公平锁:
        - ReentrantLock通过构造函数指定该锁是否是公平锁，默认是非公平锁。通过AQS(AbstractQueuedSynchronizer)的来实现线程调度。
            1. 创建公平锁
                ```
                    ReentrantLock lock = new ReentrantLock(true);
                    lock.lock(); 
               ```
            2. 创建非公平锁
                ```
                    ReentrantLock lock = new ReentrantLock(false);
                    lock.lock(); 
                ```
        - Synchronized是一种非公平锁
    
2. 可重入锁(ReentrantLock)
    1. 可重入锁: 在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁
    2. 可重入锁的优点:
        可重入锁的一个好处是可一定程度避免死锁。
    3. Java中常见的可重入锁:
        - Synchronized是一种可重入锁
        - ReentrantLock
3. 独享锁/共享锁
    1. 独享锁: 该锁一次只能被一个线程所持有
    2. 共享锁: 该锁可被多个线程所持有
   3. Java中常见独享锁/共享锁:
        - ReadWriteLock: 读锁是共享锁，写锁是独享锁。
        - Synchronized是一种独享锁
4. 互斥锁/读写锁
    1. 互斥锁:
    2. 读写锁:
    3. Java中常见的互斥锁/读写锁:
        互斥锁: ReentrantLock
        读写锁: ReadWriteLock

5. 乐观锁/悲观锁
    1. 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。
        因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
    2. 乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。
        乐观的认为，不加锁的并发操作是没有事情的
    3. 使用场景:
        - 悲观锁适合写操作非常多的场景
        - 乐观锁适合读操作非常多的场景
6. 分段锁
    
7. 自旋锁
    1. 自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU
    2. 注意: 此操作必须是在短时间内能获取到锁，不然会导致长时间线程空转。
## 锁的状态:
1. 锁的状态种类
    1. 无锁: 方法未加synchronized关键字、代码块未调用lock()方法
    2. 偏向锁
        1. 偏向锁、轻量级锁、重量级锁是指锁的状态，并且是针对Synchronized
        2. 偏向锁的作用？
            - 一般情况下，70%~80% 都只有一个线程去拿锁，基本没有多线程竞争的情况。
            - 偏向的意义在于：第一个线程拿到锁，将自己的线程信息标记在锁上，下次进来就不需要在拿去拿锁验证了。如果超过1个线程去抢锁，那么偏向锁就会撤销，升级为轻量级锁
        偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
    3. 轻量级锁
        - 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
    4. 重量级锁
        - 重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候(10次)，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。
        重量级锁会让其他申请的线程进入阻塞，性能降低。
        - 升级成重量级锁的条件: (或关系)
            - 10次自旋
            - 等待cpu调度的线程数超过cpu核数的一半
2. 锁膨胀的过程
   ![image](workspace/git/worknotes/docnet/Services/Java/Thread/Lock/imgs/Java.lock.status.webp)

## Java中锁的使用
1. synchronized

2. Object.lock()

3. ReentrantLock

4. ReadWriteLock
    