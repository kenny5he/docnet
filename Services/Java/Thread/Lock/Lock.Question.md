## 线程锁的面试题
1. 对象在内存中的内存布局是什么样的？

2. 描述synchronized和ReentrantLock的底层实现和重入的底层原理。

3. 谈谈AQS，为什么AQS底层是CAS+volatile？

4. 描述下锁的四种状态和锁升级过程？

5. Object  o = new Object() 在内存中占用多少字节？

6. 自旋锁是不是一定比重量级锁效率高？

7. 打开偏向锁是否效率一定会提升？

8. 重量级锁到底重在哪里？

9. 重量级锁什么时候比轻量级锁效率高，同样反之呢？

10. 为什么要进行锁升级？锁了就锁了，不就要加锁么？
    - 首先明确早起jdk1.2效率非常低。那时候syn就是重量级锁，申请锁必须要经过操作系统老大kernel进行系统调用，入队进行排序操作，操作完之后再返回给用户态。
11. 为什么要有偏向锁？
    - 一般情况下，70%~80% 都只有一个线程去拿锁，基本没有多线程竞争的情况。偏向的意义在于：第一个线程拿到锁，将自己的线程信息标记在锁上，下次进来就不需要在拿去拿锁验证了。如果超过1个线程去抢锁，那么偏向锁就会撤销，升级为轻量级锁
12. 为什么jdk8要在4s后开启偏向锁？
    - 明确知道在刚开始执行代码时，一定有好多线程来抢锁，如果开了偏向锁效率反而降低，所以上面程序在睡了5s之后偏向锁才开放。为什么加偏向锁效率会降低，因为中途多了几个额外的过程，上了偏向锁之后多个线程争抢共享资源的时候要进行锁升级到轻量级锁，这个过程还的把偏向锁进行撤销在进行升级，所以导致效率会降低。为什么是4s？这是一个统计的时间值。
    - 我们是可以禁止偏向锁的，通过配置参数-XX:-UseBiasedLocking = false来禁用偏向锁。jdk15之后默认已经禁用了偏向锁。本文是在jdk8的环境下做的锁升级验证
